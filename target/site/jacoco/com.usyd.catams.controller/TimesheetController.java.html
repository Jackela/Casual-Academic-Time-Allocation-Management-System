<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimesheetController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CATAMS</a> &gt; <a href="index.source.html" class="el_package">com.usyd.catams.controller</a> &gt; <span class="el_source">TimesheetController.java</span></div><h1>TimesheetController.java</h1><pre class="source lang-java linenums">package com.usyd.catams.controller;

import com.usyd.catams.dto.request.TimesheetCreateRequest;
import com.usyd.catams.dto.request.TimesheetUpdateRequest;
import com.usyd.catams.dto.response.PagedTimesheetResponse;
import com.usyd.catams.dto.response.TimesheetResponse;
import com.usyd.catams.entity.Timesheet;
import com.usyd.catams.enums.ApprovalStatus;
import com.usyd.catams.dto.response.ErrorResponse;
import com.usyd.catams.exception.ResourceNotFoundException;
import com.usyd.catams.mapper.TimesheetMapper;
import com.usyd.catams.service.TimesheetService;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

/**
 * REST Controller for timesheet management operations.
 * 
 * This controller implements the OpenAPI specification for timesheet endpoints
 * including creation, retrieval, and filtering with proper RBAC security.
 * 
 * Endpoints:
 * - POST /api/timesheets - Create new timesheet (LECTURER only)
 * - GET /api/timesheets - Retrieve timesheets with filtering (role-based access)
 * - GET /api/timesheets/{id} - Get specific timesheet by ID
 * - PUT /api/timesheets/{id} - Update existing timesheet (LECTURER/ADMIN)
 * - DELETE /api/timesheets/{id} - Delete existing timesheet (LECTURER/ADMIN)
 */
@RestController
@RequestMapping(&quot;/api/timesheets&quot;)
public class TimesheetController {

    private final TimesheetService timesheetService;
    private final TimesheetMapper timesheetMapper;

    @Autowired
<span class="fc" id="L49">    public TimesheetController(TimesheetService timesheetService, TimesheetMapper timesheetMapper) {</span>
<span class="fc" id="L50">        this.timesheetService = timesheetService;</span>
<span class="fc" id="L51">        this.timesheetMapper = timesheetMapper;</span>
<span class="fc" id="L52">    }</span>

    /**
     * Create a new timesheet.
     * 
     * Only LECTURER users can create timesheets for TUTOR users.
     * Business rules are enforced in the service layer.
     */
    @PostMapping
    @PreAuthorize(&quot;hasRole('LECTURER')&quot;)
    public ResponseEntity&lt;TimesheetResponse&gt; createTimesheet(
            @Valid @RequestBody TimesheetCreateRequest request,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="fc" id="L67">        Long creatorId = getCurrentUserId(authentication);</span>

        // Create timesheet using service layer
<span class="fc" id="L70">        Timesheet createdTimesheet = timesheetService.createTimesheet(</span>
<span class="fc" id="L71">            request.getTutorId(),</span>
<span class="fc" id="L72">            request.getCourseId(),</span>
<span class="fc" id="L73">            request.getWeekStartDate(),</span>
<span class="fc" id="L74">            request.getHours(),</span>
<span class="fc" id="L75">            request.getHourlyRate(),</span>
<span class="fc" id="L76">            request.getDescription(),</span>
            creatorId
        );

        // Convert to response DTO
<span class="fc" id="L81">        TimesheetResponse response = timesheetMapper.toResponse(createdTimesheet);</span>

<span class="fc" id="L83">        return new ResponseEntity&lt;&gt;(response, HttpStatus.CREATED);</span>
    }

    /**
     * Retrieve timesheets with filtering and pagination.
     * 
     * Access control:
     * - TUTOR: Can only view their own timesheets
     * - LECTURER: Can view timesheets for courses they teach
     * - ADMIN: Can view all timesheets
     */
    @GetMapping
    @PreAuthorize(&quot;hasRole('TUTOR') or hasRole('LECTURER') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;PagedTimesheetResponse&gt; getTimesheets(
            @RequestParam(value = &quot;tutorId&quot;, required = false) Long tutorId,
            @RequestParam(value = &quot;courseId&quot;, required = false) Long courseId,
            @RequestParam(value = &quot;status&quot;, required = false) ApprovalStatus status,
            @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) int page,
            @RequestParam(value = &quot;size&quot;, defaultValue = &quot;20&quot;) int size,
            @RequestParam(value = &quot;sort&quot;, defaultValue = &quot;createdAt,desc&quot;) String sort,
            
            Authentication authentication) {

        // Validate pagination parameters
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">        if (page &lt; 0) {</span>
<span class="nc" id="L108">            page = 0;</span>
        }
<span class="pc bpc" id="L110" title="2 of 4 branches missed.">        if (size &lt;= 0 || size &gt; 100) {</span>
<span class="nc" id="L111">            size = 20; // Default size with maximum limit</span>
        }

        // Parse sort parameter
<span class="fc" id="L115">        Pageable pageable = createPageable(page, size, sort);</span>

        // Get current user ID from authentication context
<span class="fc" id="L118">        Long requesterId = getCurrentUserId(authentication);</span>

        // Get timesheets using service layer (with access control)
<span class="fc" id="L121">        Page&lt;Timesheet&gt; timesheetsPage = timesheetService.getTimesheets(</span>
            tutorId, courseId, status, requesterId, pageable
        );

        // Convert to response DTO
<span class="fc" id="L126">        PagedTimesheetResponse response = timesheetMapper.toPagedResponse(timesheetsPage);</span>

<span class="fc" id="L128">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Get a specific timesheet by ID.
     * 
     * Access control is enforced based on user role and ownership.
     */
    @GetMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('TUTOR') or hasRole('LECTURER') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;TimesheetResponse&gt; getTimesheetById(
            @PathVariable(&quot;id&quot;) Long id,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="fc" id="L143">        Long requesterId = getCurrentUserId(authentication);</span>

        // Get timesheet using service layer (with access control)
<span class="fc" id="L146">        Optional&lt;Timesheet&gt; timesheetOpt = timesheetService.getTimesheetById(id, requesterId);</span>

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (timesheetOpt.isEmpty()) {</span>
<span class="fc" id="L149">            throw new ResourceNotFoundException(&quot;Timesheet&quot;, id.toString());</span>
        }

        // Convert to response DTO
<span class="fc" id="L153">        TimesheetResponse response = timesheetMapper.toResponse(timesheetOpt.get());</span>

<span class="fc" id="L155">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Update an existing timesheet.
     * 
     * Access control:
     * - LECTURER and ADMIN users can update timesheets (existing functionality)
     * - TUTOR can update their own REJECTED timesheets (Story 2.2 addition)
     * 
     * Business rules:
     * - LECTURER/ADMIN: Only DRAFT status timesheets can be updated
     * - TUTOR: Only REJECTED status timesheets that they own can be updated
     * - TUTOR updates reset status from REJECTED â†’ DRAFT
     * - LECTURER can update timesheets for courses they teach
     * - ADMIN can update any timesheet
     */
    @PutMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('LECTURER') or hasRole('ADMIN') or hasRole('TUTOR')&quot;)
    public ResponseEntity&lt;TimesheetResponse&gt; updateTimesheet(
            @PathVariable(&quot;id&quot;) Long id,
            @Valid @RequestBody TimesheetUpdateRequest request,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="nc" id="L180">        Long requesterId = getCurrentUserId(authentication);</span>

        // Check if user can edit this timesheet (includes TUTOR-specific logic)
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (!timesheetService.canUserEditTimesheet(id, requesterId)) {</span>
            // This will be caught by the GlobalExceptionHandler and return proper error response
<span class="nc" id="L185">            throw new SecurityException(&quot;User does not have permission to modify this timesheet&quot;);</span>
        }

        // Update timesheet using service layer
<span class="nc" id="L189">        Timesheet updatedTimesheet = timesheetService.updateTimesheet(</span>
            id,
<span class="nc" id="L191">            request.getHours(),</span>
<span class="nc" id="L192">            request.getHourlyRate(),</span>
<span class="nc" id="L193">            request.getDescription(),</span>
            requesterId
        );

        // Convert to response DTO
<span class="nc" id="L198">        TimesheetResponse response = timesheetMapper.toResponse(updatedTimesheet);</span>

<span class="nc" id="L200">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Delete an existing timesheet.
     * 
     * Access control:
     * - LECTURER and ADMIN users can delete timesheets (existing functionality)
     * - TUTOR can delete their own REJECTED timesheets (Story 2.2 addition)
     * 
     * Business rules:
     * - LECTURER/ADMIN: Only DRAFT status timesheets can be deleted
     * - TUTOR: Only REJECTED status timesheets that they own can be deleted
     * - LECTURER can delete timesheets for courses they teach
     * - ADMIN can delete any timesheet
     * - Deletion is permanent
     */
    @DeleteMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('LECTURER') or hasRole('ADMIN') or hasRole('TUTOR')&quot;)
    public ResponseEntity&lt;Void&gt; deleteTimesheet(
            @PathVariable(&quot;id&quot;) Long id,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="nc" id="L224">        Long requesterId = getCurrentUserId(authentication);</span>

        // Check if user can edit this timesheet (includes TUTOR-specific logic)
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (!timesheetService.canUserEditTimesheet(id, requesterId)) {</span>
            // This will be caught by the GlobalExceptionHandler and return proper error response
<span class="nc" id="L229">            throw new SecurityException(&quot;User does not have permission to modify this timesheet&quot;);</span>
        }

        // Delete timesheet using service layer
<span class="nc" id="L233">        timesheetService.deleteTimesheet(id, requesterId);</span>

        // Return 204 No Content as per OpenAPI specification
<span class="nc" id="L236">        return ResponseEntity.noContent().build();</span>
    }

    // Helper methods

    /**
     * Extract user ID from authentication context.
     * 
     * @param authentication the authentication object
     * @return the user ID
     */
    private Long getCurrentUserId(Authentication authentication) {
<span class="pc bpc" id="L248" title="2 of 4 branches missed.">        if (authentication == null || authentication.getPrincipal() == null) {</span>
<span class="nc" id="L249">            throw new SecurityException(&quot;Authentication required&quot;);</span>
        }

        // Extract user ID from authentication principal
        // The principal is a User object as set by JwtAuthenticationFilter
<span class="fc" id="L254">        Object principal = authentication.getPrincipal();</span>
        
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (principal instanceof com.usyd.catams.entity.User) {</span>
<span class="fc" id="L257">            return ((com.usyd.catams.entity.User) principal).getId();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        } else if (principal instanceof Long) {</span>
<span class="nc" id="L259">            return (Long) principal;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        } else if (principal instanceof String) {</span>
            try {
<span class="nc" id="L262">                return Long.parseLong((String) principal);</span>
<span class="nc" id="L263">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L264">                throw new SecurityException(&quot;Invalid user ID in authentication context&quot;);</span>
            }
        } else {
<span class="nc" id="L267">            throw new SecurityException(&quot;Invalid authentication principal type: &quot; + principal.getClass().getName());</span>
        }
    }

    /**
     * Create Pageable object from request parameters.
     * 
     * @param page the page number
     * @param size the page size
     * @param sort the sort specification
     * @return the Pageable object
     */
    private Pageable createPageable(int page, int size, String sort) {
        try {
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">            if (sort == null || sort.trim().isEmpty()) {</span>
<span class="nc" id="L282">                return PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, &quot;createdAt&quot;));</span>
            }

<span class="fc" id="L285">            String[] sortParts = sort.split(&quot;,&quot;);</span>
<span class="fc" id="L286">            String field = sortParts[0].trim();</span>
            
<span class="fc" id="L288">            Sort.Direction direction = Sort.Direction.DESC;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (sortParts.length &gt; 1) {</span>
<span class="fc" id="L290">                String directionStr = sortParts[1].trim().toLowerCase();</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">                if (&quot;asc&quot;.equals(directionStr)) {</span>
<span class="nc" id="L292">                    direction = Sort.Direction.ASC;</span>
                }
            }

            // Validate sort field (security measure to prevent SQL injection)
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if (!isValidSortField(field)) {</span>
<span class="fc" id="L298">                field = &quot;createdAt&quot;; // Default to safe field</span>
            }

<span class="fc" id="L301">            return PageRequest.of(page, size, Sort.by(direction, field));</span>
<span class="nc" id="L302">        } catch (Exception e) {</span>
            // Fallback to default sorting if parsing fails
<span class="nc" id="L304">            return PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, &quot;createdAt&quot;));</span>
        }
    }

    /**
     * Validate that the sort field is allowed.
     * 
     * @param field the field name
     * @return true if field is valid for sorting
     */
    private boolean isValidSortField(String field) {
        // Define allowed sort fields to prevent SQL injection
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        return field != null &amp;&amp; (</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            &quot;id&quot;.equals(field) ||</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            &quot;tutorId&quot;.equals(field) ||</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            &quot;courseId&quot;.equals(field) ||</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            &quot;weekStartDate&quot;.equals(field) ||</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            &quot;hours&quot;.equals(field) ||</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">            &quot;hourlyRate&quot;.equals(field) ||</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            &quot;status&quot;.equals(field) ||</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">            &quot;createdAt&quot;.equals(field) ||</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            &quot;updatedAt&quot;.equals(field)</span>
        );
    }

    /**
     * Get all timesheets for the authenticated tutor.
     * 
     * Access control:
     * - TUTOR: Can only view their own timesheets across all statuses
     * - ADMIN: Can view any user's timesheets
     * 
     * Business rules:
     * - Returns ALL timesheet statuses for complete workflow visibility
     * - Supports pagination and sorting
     * - Default sort is by creation date (newest first)
     * 
     * @param page page number (0-based)
     * @param size page size (max 100)
     * @param sort sort criteria (e.g., &quot;createdAt,desc&quot; or &quot;weekStartDate,asc&quot;)
     * @param status optional status filter
     * @param authentication current user authentication
     * @return paginated list of tutor's timesheets
     */
    @GetMapping(&quot;/me&quot;)
    @PreAuthorize(&quot;hasRole('TUTOR') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;PagedTimesheetResponse&gt; getMyTimesheets(
            @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) int page,
            @RequestParam(value = &quot;size&quot;, defaultValue = &quot;20&quot;) int size,
            @RequestParam(value = &quot;sort&quot;, defaultValue = &quot;createdAt,desc&quot;) String sort,
            @RequestParam(value = &quot;status&quot;, required = false) ApprovalStatus status,
            Authentication authentication) {
        
        try {
            // Get current user ID from authentication context
<span class="nc" id="L359">            Long requesterId = getCurrentUserId(authentication);</span>
            
            // Validate pagination parameters
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (page &lt; 0) {</span>
<span class="nc" id="L363">                page = 0;</span>
            }
<span class="nc bnc" id="L365" title="All 4 branches missed.">            if (size &lt;= 0 || size &gt; 100) {</span>
<span class="nc" id="L366">                size = 20; // Default size with maximum limit</span>
            }

            // Parse sort parameter
<span class="nc" id="L370">            Pageable pageable = createPageable(page, size, sort);</span>
            
            // Get timesheets for the tutor
<span class="nc" id="L373">            Page&lt;Timesheet&gt; timesheetPage = timesheetService.getTimesheetsByTutor(requesterId, pageable);</span>
            
            // Apply status filtering if provided
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (status != null) {</span>
                // Filter in service layer for better performance
<span class="nc" id="L378">                timesheetPage = timesheetService.getTimesheets(requesterId, null, status, requesterId, pageable);</span>
            }
            
            // Convert to response DTO
<span class="nc" id="L382">            PagedTimesheetResponse response = timesheetMapper.toPagedResponse(timesheetPage);</span>
            
<span class="nc" id="L384">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L386">        } catch (SecurityException e) {</span>
<span class="nc" id="L387">            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();</span>
<span class="nc" id="L388">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L389">            return ResponseEntity.badRequest().build();</span>
<span class="nc" id="L390">        } catch (Exception e) {</span>
<span class="nc" id="L391">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span>
        }
    }

    /**
     * Get timesheets pending lecturer approval with pagination.
     * 
     * Access control:
     * - LECTURER: Can view timesheets pending approval for their courses only
     * - ADMIN: Can view all timesheets pending approval system-wide
     * - TUTOR: Cannot access this endpoint (403 Forbidden)
     * 
     * Business rules:
     * - Only returns timesheets with status PENDING_LECTURER_APPROVAL
     * - Results are filtered by lecturer's assigned courses (unless ADMIN)
     * - Default sort is by submission date (oldest first for priority)
     * 
     * @param page page number (0-based)
     * @param size page size (max 100)
     * @param sort sort criteria (e.g., &quot;createdAt,asc&quot; or &quot;weekStartDate,desc&quot;)
     * @param courseId optional course ID filter (ADMIN only, ignored for LECTURER)
     * @return paginated list of timesheets pending lecturer approval
     */
    @GetMapping(&quot;/pending-approval&quot;)
    @PreAuthorize(&quot;hasRole('LECTURER') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;PagedTimesheetResponse&gt; getPendingApprovalTimesheets(
            @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) int page,
            @RequestParam(value = &quot;size&quot;, defaultValue = &quot;20&quot;) int size,
            @RequestParam(value = &quot;sort&quot;, defaultValue = &quot;createdAt,asc&quot;) String sort,
            @RequestParam(value = &quot;courseId&quot;, required = false) Long courseId) {
        
        try {
            // Get current user ID from security context
<span class="nc" id="L424">            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (authentication == null) {</span>
<span class="nc" id="L426">                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span>
            }
            
<span class="nc" id="L429">            Long requesterId = getCurrentUserId(authentication);</span>
            
            // Validate pagination parameters
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if (page &lt; 0) page = 0;</span>
<span class="nc bnc" id="L433" title="All 4 branches missed.">            if (size &lt;= 0 || size &gt; 100) size = 20;</span>
            
            // Validate and create pageable with default sort
<span class="nc" id="L436">            Pageable pageable = createPageable(page, size, sort);</span>
            
            // Get pending approval timesheets with proper error handling
<span class="nc" id="L439">            Page&lt;Timesheet&gt; timesheetPage = timesheetService.getPendingApprovalTimesheets(requesterId, pageable);</span>
            
            // Convert to response DTO
<span class="nc" id="L442">            PagedTimesheetResponse response = timesheetMapper.toPagedResponse(timesheetPage);</span>
            
<span class="nc" id="L444">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L446">        } catch (SecurityException e) {</span>
<span class="nc" id="L447">            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();</span>
<span class="nc" id="L448">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L449">            return ResponseEntity.badRequest().build();</span>
<span class="nc" id="L450">        } catch (Exception e) {</span>
            // Log the error for debugging in E2E environment
<span class="nc" id="L452">            System.err.println(&quot;Error in getPendingApprovalTimesheets: &quot; + e.getMessage());</span>
<span class="nc" id="L453">            e.printStackTrace();</span>
<span class="nc" id="L454">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>