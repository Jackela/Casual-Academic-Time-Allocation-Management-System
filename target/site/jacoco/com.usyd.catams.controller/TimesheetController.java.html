<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TimesheetController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CATAMS</a> &gt; <a href="index.source.html" class="el_package">com.usyd.catams.controller</a> &gt; <span class="el_source">TimesheetController.java</span></div><h1>TimesheetController.java</h1><pre class="source lang-java linenums">package com.usyd.catams.controller;

import com.usyd.catams.application.TimesheetApplicationService;
import com.usyd.catams.dto.request.TimesheetCreateRequest;
import com.usyd.catams.dto.request.TimesheetUpdateRequest;
import com.usyd.catams.dto.response.PagedTimesheetResponse;
import com.usyd.catams.dto.response.TimesheetResponse;
import com.usyd.catams.enums.ApprovalStatus;
import com.usyd.catams.exception.ResourceNotFoundException;
import com.usyd.catams.security.AuthenticationUtils;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

/**
 * REST Controller for timesheet management operations.
 * 
 * This controller implements the OpenAPI specification for timesheet endpoints
 * including creation, retrieval, and filtering with proper RBAC security.
 * 
 * Endpoints:
 * - POST /api/timesheets - Create new timesheet (LECTURER only)
 * - GET /api/timesheets - Retrieve timesheets with filtering (role-based access)
 * - GET /api/timesheets/{id} - Get specific timesheet by ID
 * - PUT /api/timesheets/{id} - Update existing timesheet (LECTURER/ADMIN)
 * - DELETE /api/timesheets/{id} - Delete existing timesheet (LECTURER/ADMIN)
 */
@RestController
@RequestMapping(&quot;/api/timesheets&quot;)
public class TimesheetController {

    private final TimesheetApplicationService timesheetApplicationService;
    private final AuthenticationUtils authenticationUtils;

    @Autowired
<span class="fc" id="L47">    public TimesheetController(TimesheetApplicationService timesheetApplicationService, </span>
                              AuthenticationUtils authenticationUtils) {
<span class="fc" id="L49">        this.timesheetApplicationService = timesheetApplicationService;</span>
<span class="fc" id="L50">        this.authenticationUtils = authenticationUtils;</span>
<span class="fc" id="L51">    }</span>

    /**
     * Create a new timesheet.
     * 
     * Only LECTURER users can create timesheets for TUTOR users.
     * Business rules are enforced in the service layer.
     */
    @PostMapping
    @PreAuthorize(&quot;hasRole('LECTURER')&quot;)
    public ResponseEntity&lt;TimesheetResponse&gt; createTimesheet(
            @Valid @RequestBody TimesheetCreateRequest request,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="fc" id="L66">        Long creatorId = authenticationUtils.getCurrentUserId(authentication);</span>

        // Create timesheet using application service (returns DTO directly)
<span class="fc" id="L69">        TimesheetResponse response = timesheetApplicationService.createTimesheetAndReturnDto(</span>
<span class="fc" id="L70">            request.getTutorId(),</span>
<span class="fc" id="L71">            request.getCourseId(),</span>
<span class="fc" id="L72">            request.getWeekStartDate(),</span>
<span class="fc" id="L73">            request.getHours(),</span>
<span class="fc" id="L74">            request.getHourlyRate(),</span>
<span class="fc" id="L75">            request.getDescription(),</span>
<span class="fc" id="L76">            creatorId</span>
        );

<span class="fc" id="L79">        return new ResponseEntity&lt;&gt;(response, HttpStatus.CREATED);</span>
    }

    /**
     * Retrieve timesheets with filtering and pagination.
     * 
     * Access control:
     * - TUTOR: Can only view their own timesheets
     * - LECTURER: Can view timesheets for courses they teach
     * - ADMIN: Can view all timesheets
     */
    @GetMapping
    @PreAuthorize(&quot;hasRole('TUTOR') or hasRole('LECTURER') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;PagedTimesheetResponse&gt; getTimesheets(
            @RequestParam(value = &quot;tutorId&quot;, required = false) Long tutorId,
            @RequestParam(value = &quot;courseId&quot;, required = false) Long courseId,
            @RequestParam(value = &quot;status&quot;, required = false) ApprovalStatus status,
            @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) int page,
            @RequestParam(value = &quot;size&quot;, defaultValue = &quot;20&quot;) int size,
            @RequestParam(value = &quot;sort&quot;, defaultValue = &quot;createdAt,desc&quot;) String sort,
            
            Authentication authentication) {

        // Validate pagination parameters
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (page &lt; 0) {</span>
<span class="nc" id="L104">            page = 0;</span>
        }
<span class="pc bpc" id="L106" title="2 of 4 branches missed.">        if (size &lt;= 0 || size &gt; 100) {</span>
<span class="nc" id="L107">            size = 20; // Default size with maximum limit</span>
        }

        // Parse sort parameter
<span class="fc" id="L111">        Pageable pageable = createPageable(page, size, sort);</span>

        // Get current user ID from authentication context
<span class="fc" id="L114">        Long requesterId = authenticationUtils.getCurrentUserId(authentication);</span>

        // Get timesheets using application service (returns DTO directly)
<span class="fc" id="L117">        PagedTimesheetResponse response = timesheetApplicationService.getTimesheetsAsDto(</span>
<span class="fc" id="L118">            tutorId, courseId, status, requesterId, pageable</span>
        );

<span class="fc" id="L121">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Get a specific timesheet by ID.
     * 
     * Access control is enforced based on user role and ownership.
     */
    @GetMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('TUTOR') or hasRole('LECTURER') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;TimesheetResponse&gt; getTimesheetById(
            @PathVariable(&quot;id&quot;) Long id,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="fc" id="L136">        Long requesterId = authenticationUtils.getCurrentUserId(authentication);</span>

        // Get timesheet using application service (returns DTO directly)
<span class="fc" id="L139">        Optional&lt;TimesheetResponse&gt; timesheetResponseOpt = timesheetApplicationService.getTimesheetByIdAsDto(id, requesterId);</span>

<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (timesheetResponseOpt.isEmpty()) {</span>
<span class="nc" id="L142">            throw new ResourceNotFoundException(&quot;Timesheet&quot;, id.toString());</span>
        }

        // Return the DTO response
<span class="fc" id="L146">        TimesheetResponse response = timesheetResponseOpt.get();</span>

<span class="fc" id="L148">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Update an existing timesheet.
     * 
     * Access control:
     * - LECTURER and ADMIN users can update timesheets (existing functionality)
     * - TUTOR can update their own REJECTED timesheets (Story 2.2 addition)
     * 
     * Business rules:
     * - LECTURER/ADMIN: Only DRAFT status timesheets can be updated
     * - TUTOR: Only REJECTED status timesheets that they own can be updated
     * - TUTOR updates reset status from REJECTED → DRAFT
     * - LECTURER can update timesheets for courses they teach
     * - ADMIN can update any timesheet
     */
    @PutMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('LECTURER') or hasRole('ADMIN') or hasRole('TUTOR')&quot;)
    public ResponseEntity&lt;TimesheetResponse&gt; updateTimesheet(
            @PathVariable(&quot;id&quot;) Long id,
            @Valid @RequestBody TimesheetUpdateRequest request,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="fc" id="L173">        Long requesterId = authenticationUtils.getCurrentUserId(authentication);</span>

        // Check if user can edit this timesheet (includes TUTOR-specific logic)
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (!timesheetApplicationService.canUserEditTimesheet(id, requesterId)) {</span>
            // This will be caught by the GlobalExceptionHandler and return proper error response
<span class="fc" id="L178">            throw new SecurityException(&quot;User does not have permission to modify this timesheet&quot;);</span>
        }

        // Update timesheet using application service (returns DTO directly)
<span class="fc" id="L182">        TimesheetResponse response = timesheetApplicationService.updateTimesheetAndReturnDto(</span>
<span class="fc" id="L183">            id,</span>
<span class="fc" id="L184">            request.getHours(),</span>
<span class="fc" id="L185">            request.getHourlyRate(),</span>
<span class="fc" id="L186">            request.getDescription(),</span>
<span class="fc" id="L187">            requesterId</span>
        );

<span class="fc" id="L190">        return ResponseEntity.ok(response);</span>
    }

    /**
     * Delete an existing timesheet.
     * 
     * Access control:
     * - LECTURER and ADMIN users can delete timesheets (existing functionality)
     * - TUTOR can delete their own REJECTED timesheets (Story 2.2 addition)
     * 
     * Business rules:
     * - LECTURER/ADMIN: Only DRAFT status timesheets can be deleted
     * - TUTOR: Only REJECTED status timesheets that they own can be deleted
     * - LECTURER can delete timesheets for courses they teach
     * - ADMIN can delete any timesheet
     * - Deletion is permanent
     */
    @DeleteMapping(&quot;/{id}&quot;)
    @PreAuthorize(&quot;hasRole('LECTURER') or hasRole('ADMIN') or hasRole('TUTOR')&quot;)
    public ResponseEntity&lt;Void&gt; deleteTimesheet(
            @PathVariable(&quot;id&quot;) Long id,
            Authentication authentication) {

        // Get current user ID from authentication context
<span class="fc" id="L214">        Long requesterId = authenticationUtils.getCurrentUserId(authentication);</span>

        // Check if user can edit this timesheet (includes TUTOR-specific logic)
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (!timesheetApplicationService.canUserEditTimesheet(id, requesterId)) {</span>
            // This will be caught by the GlobalExceptionHandler and return proper error response
<span class="fc" id="L219">            throw new SecurityException(&quot;User does not have permission to modify this timesheet&quot;);</span>
        }

        // Delete timesheet using application service
<span class="fc" id="L223">        timesheetApplicationService.deleteTimesheet(id, requesterId);</span>

        // Return 204 No Content as per OpenAPI specification
<span class="fc" id="L226">        return ResponseEntity.noContent().build();</span>
    }

    // Helper methods


    /**
     * Create Pageable object from request parameters.
     * 
     * @param page the page number
     * @param size the page size
     * @param sort the sort specification
     * @return the Pageable object
     */
    private Pageable createPageable(int page, int size, String sort) {
        try {
<span class="pc bpc" id="L242" title="2 of 4 branches missed.">            if (sort == null || sort.trim().isEmpty()) {</span>
<span class="nc" id="L243">                return PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, &quot;createdAt&quot;));</span>
            }

<span class="fc" id="L246">            String[] sortParts = sort.split(&quot;,&quot;);</span>
<span class="fc" id="L247">            String field = sortParts[0].trim();</span>
            
<span class="fc" id="L249">            Sort.Direction direction = Sort.Direction.DESC;</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">            if (sortParts.length &gt; 1) {</span>
<span class="fc" id="L251">                String directionStr = sortParts[1].trim().toLowerCase();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                if (&quot;asc&quot;.equals(directionStr)) {</span>
<span class="fc" id="L253">                    direction = Sort.Direction.ASC;</span>
                }
            }

            // Validate sort field (security measure to prevent SQL injection)
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">            if (!isValidSortField(field)) {</span>
<span class="nc" id="L259">                field = &quot;createdAt&quot;; // Default to safe field</span>
            }

<span class="fc" id="L262">            return PageRequest.of(page, size, Sort.by(direction, field));</span>
<span class="nc" id="L263">        } catch (Exception e) {</span>
            // Fallback to default sorting if parsing fails
<span class="nc" id="L265">            return PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, &quot;createdAt&quot;));</span>
        }
    }

    /**
     * Validate that the sort field is allowed.
     * 
     * @param field the field name
     * @return true if field is valid for sorting
     */
    private boolean isValidSortField(String field) {
        // Define allowed sort fields to prevent SQL injection
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        return field != null &amp;&amp; (</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            &quot;id&quot;.equals(field) ||</span>
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">            &quot;tutorId&quot;.equals(field) ||</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            &quot;courseId&quot;.equals(field) ||</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">            &quot;weekStartDate&quot;.equals(field) ||</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            &quot;hours&quot;.equals(field) ||</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            &quot;hourlyRate&quot;.equals(field) ||</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">            &quot;status&quot;.equals(field) ||</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">            &quot;createdAt&quot;.equals(field) ||</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            &quot;updatedAt&quot;.equals(field)</span>
        );
    }

    /**
     * Get all timesheets for the authenticated tutor.
     * 
     * Access control:
     * - TUTOR: Can only view their own timesheets across all statuses
     * - ADMIN: Can view any user's timesheets
     * 
     * Business rules:
     * - Returns ALL timesheet statuses for complete workflow visibility
     * - Supports pagination and sorting
     * - Default sort is by creation date (newest first)
     * 
     * @param page page number (0-based)
     * @param size page size (max 100)
     * @param sort sort criteria (e.g., &quot;createdAt,desc&quot; or &quot;weekStartDate,asc&quot;)
     * @param status optional status filter
     * @param authentication current user authentication
     * @return paginated list of tutor's timesheets
     */
    @GetMapping(&quot;/me&quot;)
    @PreAuthorize(&quot;hasRole('TUTOR') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;PagedTimesheetResponse&gt; getMyTimesheets(
            @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) int page,
            @RequestParam(value = &quot;size&quot;, defaultValue = &quot;20&quot;) int size,
            @RequestParam(value = &quot;sort&quot;, defaultValue = &quot;createdAt,desc&quot;) String sort,
            @RequestParam(value = &quot;status&quot;, required = false) ApprovalStatus status,
            Authentication authentication) {
        
        try {
            // Get current user ID from authentication context
<span class="fc" id="L320">            Long requesterId = authenticationUtils.getCurrentUserId(authentication);</span>
            
            // Validate pagination parameters
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            if (page &lt; 0) {</span>
<span class="nc" id="L324">                page = 0;</span>
            }
<span class="pc bpc" id="L326" title="2 of 4 branches missed.">            if (size &lt;= 0 || size &gt; 100) {</span>
<span class="nc" id="L327">                size = 20; // Default size with maximum limit</span>
            }

            // Parse sort parameter
<span class="fc" id="L331">            Pageable pageable = createPageable(page, size, sort);</span>
            
            // Get timesheets for the tutor using application service (returns DTO directly)
            PagedTimesheetResponse response;
<span class="fc bfc" id="L335" title="All 2 branches covered.">            if (status != null) {</span>
                // Filter in service layer for better performance
<span class="fc" id="L337">                response = timesheetApplicationService.getTimesheetsAsDto(requesterId, null, status, requesterId, pageable);</span>
<span class="fc" id="L338">            } else {</span>
<span class="fc" id="L339">                response = timesheetApplicationService.getTimesheetsByTutorAsDto(requesterId, pageable);</span>
            }
            
<span class="fc" id="L342">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L344">        } catch (SecurityException e) {</span>
<span class="nc" id="L345">            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();</span>
<span class="nc" id="L346">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L347">            return ResponseEntity.badRequest().build();</span>
<span class="nc" id="L348">        } catch (Exception e) {</span>
<span class="nc" id="L349">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span>
        }
    }

    /**
     * Get timesheets pending lecturer approval with pagination.
     * 
     * Access control:
     * - LECTURER: Can view timesheets pending approval for their courses only
     * - ADMIN: Can view all timesheets pending approval system-wide
     * - TUTOR: Cannot access this endpoint (403 Forbidden)
     * 
     * Business rules:
     * - Only returns timesheets with status PENDING_LECTURER_APPROVAL
     * - Results are filtered by lecturer's assigned courses (unless ADMIN)
     * - Default sort is by submission date (oldest first for priority)
     * 
     * @param page page number (0-based)
     * @param size page size (max 100)
     * @param sort sort criteria (e.g., &quot;createdAt,asc&quot; or &quot;weekStartDate,desc&quot;)
     * @param courseId optional course ID filter (ADMIN only, ignored for LECTURER)
     * @return paginated list of timesheets pending lecturer approval
     */
    @GetMapping(&quot;/pending-approval&quot;)
    @PreAuthorize(&quot;hasRole('TUTOR') or hasRole('LECTURER') or hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;PagedTimesheetResponse&gt; getPendingApprovalTimesheets(
            @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) int page,
            @RequestParam(value = &quot;size&quot;, defaultValue = &quot;20&quot;) int size,
            @RequestParam(value = &quot;sort&quot;, defaultValue = &quot;createdAt,asc&quot;) String sort,
            @RequestParam(value = &quot;courseId&quot;, required = false) Long courseId) {
        
        try {
            // Get current user ID from security context
<span class="fc" id="L382">            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">            if (authentication == null) {</span>
<span class="nc" id="L384">                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span>
            }

            // ADR CATAMS-ADR-001: Lecturers are creators, not approvers → forbid access
<span class="fc" id="L388">            boolean isLecturer = authentication.getAuthorities().stream()</span>
<span class="fc" id="L389">                .map(GrantedAuthority::getAuthority)</span>
<span class="fc" id="L390">                .anyMatch(&quot;ROLE_LECTURER&quot;::equals);</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">            if (isLecturer) {</span>
<span class="fc" id="L392">                return ResponseEntity.status(HttpStatus.FORBIDDEN).build();</span>
            }
            
<span class="fc" id="L395">            Long requesterId = authenticationUtils.getCurrentUserId(authentication);</span>
            
            // Validate pagination parameters
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if (page &lt; 0) page = 0;</span>
<span class="pc bpc" id="L399" title="2 of 4 branches missed.">            if (size &lt;= 0 || size &gt; 100) size = 20;</span>
            
            // Validate and create pageable with default sort
<span class="fc" id="L402">            Pageable pageable = createPageable(page, size, sort);</span>
            
            // Get pending approval timesheets using application service (returns DTO directly)
<span class="fc" id="L405">            PagedTimesheetResponse response = timesheetApplicationService.getPendingApprovalTimesheetsAsDto(requesterId, pageable);</span>
            
<span class="fc" id="L407">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L409">        } catch (SecurityException e) {</span>
<span class="nc" id="L410">            return ResponseEntity.status(HttpStatus.FORBIDDEN).build();</span>
<span class="nc" id="L411">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L412">            return ResponseEntity.badRequest().build();</span>
<span class="nc" id="L413">        } catch (Exception e) {</span>
            // Log the error for debugging in E2E environment
<span class="nc" id="L415">            System.err.println(&quot;Error in getPendingApprovalTimesheets: &quot; + e.getMessage());</span>
<span class="nc" id="L416">            e.printStackTrace();</span>
<span class="nc" id="L417">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>