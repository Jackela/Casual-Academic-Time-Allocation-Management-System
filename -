import { APIRequestContext, APIResponse, expect } from "@playwright/test";
import { E2E_CONFIG } from '../config/e2e.config';

export interface AuthContext {
  admin: { token: string; userId: number };
  lecturer: { token: string; userId: number };
  tutor: { token: string; userId: number };
}

type TimesheetStatus =
  | 'DRAFT'
  | 'PENDING_TUTOR_CONFIRMATION'
  | 'TUTOR_CONFIRMED'
  | 'LECTURER_CONFIRMED'
  | 'FINAL_CONFIRMED'
  | 'REJECTED'
  | 'MODIFICATION_REQUESTED';

export interface TimesheetSeedOptions {
  description?: string;
  hours?: number;
  hourlyRate?: number;
  courseId?: number;
  weekStartDate?: string;
  targetStatus?: TimesheetStatus;
  taskType?: 'TUTORIAL' | 'LECTURE' | 'ORAA' | 'DEMO' | 'MARKING' | 'OTHER';
  qualification?: 'STANDARD' | 'PHD' | 'COORDINATOR';
  repeat?: boolean;
  sessionDate?: string;
  deliveryHours?: number;
}

export interface SeededTimesheet {
  id: number;
  description: string;
  courseId: number;
  weekStartDate: string;
  status?: TimesheetStatus;
}

export type ApprovalTransition =
  | 'SUBMIT_FOR_APPROVAL'
  | 'TUTOR_CONFIRM'
  | 'LECTURER_CONFIRM'
  | 'HR_CONFIRM'
  | 'REJECT'
  | 'REQUEST_MODIFICATION';

const KNOWN_STATUSES: ReadonlyArray<TimesheetStatus> = [
  'DRAFT',
  'PENDING_TUTOR_CONFIRMATION',
  'TUTOR_CONFIRMED',
  'LECTURER_CONFIRMED',
  'FINAL_CONFIRMED',
  'REJECTED',
  'MODIFICATION_REQUESTED'
] as const;

const STATUS_NORMALIZATION_MAP: Record<string, TimesheetStatus> = {
  PENDING_LECTURER_APPROVAL: 'PENDING_TUTOR_CONFIRMATION',
  PENDING_TUTOR_REVIEW: 'PENDING_TUTOR_CONFIRMATION',
  PENDING_HR_REVIEW: 'LECTURER_CONFIRMED',
  HR_APPROVED: 'FINAL_CONFIRMED',
  APPROVED: 'FINAL_CONFIRMED'
};

const ACTION_TARGET_STATUS: Record<ApprovalTransition, TimesheetStatus | null> = {
  SUBMIT_FOR_APPROVAL: 'PENDING_TUTOR_CONFIRMATION',
  TUTOR_CONFIRM: 'TUTOR_CONFIRMED',
  LECTURER_CONFIRM: 'LECTURER_CONFIRMED',
  HR_CONFIRM: 'FINAL_CONFIRMED',
  REJECT: 'REJECTED',
  REQUEST_MODIFICATION: 'MODIFICATION_REQUESTED'
};

const ACTION_ALLOWED_FROM: Record<ApprovalTransition, TimesheetStatus[]> = {
  SUBMIT_FOR_APPROVAL: ['DRAFT', 'MODIFICATION_REQUESTED'],
  TUTOR_CONFIRM: ['PENDING_TUTOR_CONFIRMATION'],
  LECTURER_CONFIRM: ['TUTOR_CONFIRMED'],
  HR_CONFIRM: ['LECTURER_CONFIRMED'],
  REJECT: ['PENDING_TUTOR_CONFIRMATION', 'TUTOR_CONFIRMED', 'LECTURER_CONFIRMED'],
  REQUEST_MODIFICATION: ['PENDING_TUTOR_CONFIRMATION', 'TUTOR_CONFIRMED', 'LECTURER_CONFIRMED']
};

type TransitionStep = {
  action: ApprovalTransition;
  actor: 'tutor' | 'lecturer' | 'admin';
  comment?: string;
};

const STATUS_TRANSITION_PLAN: Record<TimesheetStatus, TransitionStep[]> = {
  DRAFT: [],
  PENDING_TUTOR_CONFIRMATION: [
    { action: 'SUBMIT_FOR_APPROVAL', actor: 'tutor' }
  ],
  TUTOR_CONFIRMED: [
    { action: 'SUBMIT_FOR_APPROVAL', actor: 'tutor' },
    { action: 'TUTOR_CONFIRM', actor: 'tutor' }
  ],
  LECTURER_CONFIRMED: [
    { action: 'SUBMIT_FOR_APPROVAL', actor: 'tutor' },
    { action: 'TUTOR_CONFIRM', actor: 'tutor' },
    { action: 'LECTURER_CONFIRM', actor: 'lecturer' }
  ],
  FINAL_CONFIRMED: [
    { action: 'SUBMIT_FOR_APPROVAL', actor: 'tutor' },
    { action: 'TUTOR_CONFIRM', actor: 'tutor' },
    { action: 'LECTURER_CONFIRM', actor: 'lecturer' },
    { action: 'HR_CONFIRM', actor: 'admin' }
  ],
  REJECTED: [
    { action: 'SUBMIT_FOR_APPROVAL', actor: 'tutor' },
    { action: 'REJECT', actor: 'admin', comment: 'Seeded rejection' }
  ],
  MODIFICATION_REQUESTED: [
    { action: 'SUBMIT_FOR_APPROVAL', actor: 'tutor' },
    { action: 'REQUEST_MODIFICATION', actor: 'lecturer', comment: 'Seeded modification request' }
  ]
};

const backendUrl = E2E_CONFIG.BACKEND.URL;
const approvalsEndpoint = `${backendUrl}${E2E_CONFIG.BACKEND.ENDPOINTS.APPROVALS}`;
const timesheetsEndpoint = `${backendUrl}${E2E_CONFIG.BACKEND.ENDPOINTS.TIMESHEETS}`;
const loginEndpoint = `${backendUrl}${E2E_CONFIG.BACKEND.ENDPOINTS.AUTH_LOGIN}`;


const parseNumericEnv = (...values: (string | undefined)[]): number | null => {
  for (const value of values) {
    if (!value) continue;
    const match = value.match(/-?\\d+/);
    if (!match) continue;
    const parsed = Number.parseInt(match[0], 10);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  return null;
};

const WORKER_WEEK_STRIDE = Math.max(1, parseNumericEnv(process.env.E2E_WORKER_WEEK_STRIDE) ?? 4);
const WORKER_INDEX = parseNumericEnv(process.env.PLAYWRIGHT_WORKER_INDEX, process.env.PLAYWRIGHT_WORKER_ID) ?? 0;
const RUN_SALT = parseNumericEnv(process.env.PLAYWRIGHT_RUN_SALT, process.env.GITHUB_RUN_ID, process.env.CI_JOB_ID, String(process.pid)) ?? process.pid ?? Number(String(Date.now()).slice(-7));
const RUN_WEEK_SHIFT = Math.abs(RUN_SALT % 26);


const toHeaders = (token: string) => ({
  Authorization: `Bearer ${token}`,
  'Content-Type': 'application/json'
});

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

const normalizeStatus = (value: unknown): TimesheetStatus | null => {
  if (!value) {
    return null;
  }
  const upper = String(value).toUpperCase();
  if (STATUS_NORMALIZATION_MAP[upper]) {
    return STATUS_NORMALIZATION_MAP[upper];
  }
  return KNOWN_STATUSES.find(status => status === upper) ?? null;
};

const getActorToken = (tokens: AuthContext, actor: 'tutor' | 'lecturer' | 'admin'): string => {
  switch (actor) {
    case 'tutor':
      return tokens.tutor.token;
    case 'lecturer':
      return tokens.lecturer.token;
    case 'admin':
    default:
      return tokens.admin.token;
  }
};

const extractStatusField = (payload: unknown): unknown => {
  if (!payload || typeof payload !== 'object') {
    return undefined;
  }
  const candidate = (payload as Record<string, unknown>);
  return (
    candidate.status ??
    candidate.currentStatus ??
    (candidate.timesheet && extractStatusField(candidate.timesheet)) ??
    (candidate.data && extractStatusField(candidate.data))
  );
};

async function fetchTimesheetStatus(
  request: APIRequestContext,
  token: string,
  timesheetId: number
): Promise<TimesheetStatus | null> {
  const response = await request.get(`${timesheetsEndpoint}/${timesheetId}`, {
    headers: toHeaders(token)
  });

  if (!response.ok()) {
    throw new Error(`Failed to fetch timesheet ${timesheetId} status: ${response.status()} ${await response.text()}`);
  }

  const payload = await response.json().catch(() => null);
  return normalizeStatus(extractStatusField(payload));
}

async function waitForTimesheetStatus(
  request: APIRequestContext,
  tokens: AuthContext,
  timesheetId: number,
  expected: TimesheetStatus,
  timeout = 10000
): Promise<TimesheetStatus> {
  let resolved: TimesheetStatus | null = null;

  await expect(async () => {
    resolved = await fetchTimesheetStatus(request, tokens.admin.token, timesheetId);
    expect(resolved).toBe(expected);
  }).toPass({ timeout });

  if (!resolved) {
    throw new Error(`Unable to resolve status for timesheet ${timesheetId}`);
  }

  return resolved;
}

async function authenticate(request: APIRequestContext, email: string, password: string) {
  const response = await request.post(loginEndpoint, {
    headers: { 'Content-Type': 'application/json' },
    data: { email, password }
  });

  if (!response.ok()) {
    throw new Error(`Login failed for ${email}: ${response.status()} ${await response.text()}`);
  }

  const body = await response.json();
  if (!body?.token || !body?.user?.id) {
    throw new Error(`Unexpected login response for ${email}`);
  }
