const fs = require('fs');
const path = require('path');
const LifecycleManager = require('../../process-management/src/managers/LifecycleManager');

/**
 * SafeProcessManager coordinates tracked process termination for a specific test session.
 * It relies on a session ledger generated by the orchestrator to understand which PIDs
 * belong to the active session before invoking LifecycleManager to terminate them.
 */
class SafeProcessManager {
  /**
   * @param {Object} options
   * @param {string} [options.sessionId] - Active session identifier
   * @param {string} [options.ledgerPath] - Absolute path to the session ledger JSON
   * @param {LifecycleManager} [options.lifecycleManager] - Optional lifecycle manager instance
   * @param {Function} [options.log] - Optional logger function
   */
  constructor (options = {}) {
    this.sessionId = options.sessionId || process.env.CATAMS_SESSION_ID || null;
    this.ledgerPath = options.ledgerPath ||
      process.env.CATAMS_PROCESS_LEDGER ||
      path.join(__dirname, '..', '..', 'process-management', '.process-ledger.json');

    this.lifecycleManager = options.lifecycleManager || new LifecycleManager();
    this.log = typeof options.log === 'function' ? options.log : (() => {});

    this._ledgerCache = null;
  }

  /**
   * Returns true when both a session identifier and ledger information are available.
   * @returns {boolean}
   */
  isActive () {
    if (!this.sessionId) {
      return false;
    }

    const ledger = this._loadLedger();
    const sessionEntry = ledger.sessions[this.sessionId];
    return Boolean(sessionEntry && sessionEntry.processes.length);
  }

  /**
   * Load and normalize the ledger content.
   * @returns {{sessions: Object<string,{processes: Array}>}}
   * @private
   */
  _loadLedger () {
    if (this._ledgerCache) {
      return this._ledgerCache;
    }

    const empty = { sessions: {} };

    if (!this.ledgerPath || !fs.existsSync(this.ledgerPath)) {
      this._ledgerCache = empty;
      return this._ledgerCache;
    }

    try {
      const raw = fs.readFileSync(this.ledgerPath, 'utf-8');
      const parsed = JSON.parse(raw);
      this._ledgerCache = this._normaliseLedger(parsed);
    } catch (error) {
      this.log(`Failed to read process ledger: ${error.message}`, 'WARN');
      this._ledgerCache = empty;
    }

    return this._ledgerCache;
  }

  /**
   * Normalise possible ledger formats into a single structure.
   * @param {*} data
   * @returns {{sessions: Object<string,{processes: Array}>}}
   * @private
   */
  _normaliseLedger (data) {
    const ledger = { sessions: {} };

    if (!data) {
      return ledger;
    }

    // Format: { sessions: { sessionId: { processes: [] } } }
    if (typeof data === 'object' && !Array.isArray(data) && data.sessions) {
      for (const [key, value] of Object.entries(data.sessions)) {
        ledger.sessions[key] = {
          processes: Array.isArray(value.processes) ? value.processes : []
        };
      }
      return ledger;
    }

    // Format: { sessionId: [...] }
    if (typeof data === 'object' && !Array.isArray(data)) {
      for (const [key, value] of Object.entries(data)) {
        ledger.sessions[key] = { processes: Array.isArray(value) ? value : [] };
      }
      return ledger;
    }

    // Format: Array of { sessionId, ... }
    if (Array.isArray(data)) {
      for (const entry of data) {
        if (!entry || typeof entry !== 'object') {
          continue;
        }
        const sessionKey = entry.sessionId;
        if (!sessionKey) {
          continue;
        }

        if (!ledger.sessions[sessionKey]) {
          ledger.sessions[sessionKey] = { processes: [] };
        }

        ledger.sessions[sessionKey].processes.push(entry);
      }
    }

    return ledger;
  }

  /**
   * Retrieve all tracked processes for the active session.
   * @returns {Array<{pid:number,name?:string,command?:string,metadata?:Object}>}
   */
  getTrackedProcesses () {
    if (!this.sessionId) {
      return [];
    }

    const ledger = this._loadLedger();
    const sessionEntry = ledger.sessions[this.sessionId];
    if (!sessionEntry) {
      return [];
    }

    return sessionEntry.processes
      .filter(proc => proc && Number.isInteger(proc.pid))
      .map(proc => ({
        pid: proc.pid,
        name: proc.name || proc.processName || '',
        command: proc.command || proc.cmd || '',
        metadata: proc.metadata || {}
      }));
  }

  /**
   * Filter the provided PID list down to those tracked in the session ledger.
   * @param {Array<number>} pids
   * @returns {Array<number>}
   */
  filterTrackedPids (pids = []) {
    if (!Array.isArray(pids) || pids.length === 0) {
      return [];
    }

    const trackedPids = new Set(this.getTrackedProcesses().map(proc => proc.pid));
    return pids.filter(pid => trackedPids.has(pid));
  }

  /**
   * Terminate a collection of tracked process IDs.
   * @param {Array<number>} pids
   * @param {Object} options
   * @returns {Promise<{attempted:number,terminated:number,errors:Array}>}
   */
  async terminatePids (pids = [], options = {}) {
    const tracked = this.filterTrackedPids(pids);
    const result = { attempted: tracked.length, terminated: 0, errors: [] };

    if (!tracked.length) {
      return result;
    }

    for (const pid of tracked) {
      try {
        await this.lifecycleManager.terminateProcess(pid, {
          force: options.force !== false,
          timeout: options.timeout || 5000
        });
        result.terminated++;
      } catch (error) {
        result.errors.push({ pid, error: error.message });
        this.log(`Failed to terminate tracked PID ${pid}: ${error.message}`, 'WARN');
      }
    }

    return result;
  }

  /**
   * Terminate tracked processes whose name or command matches provided patterns.
   * @param {Array<string>} patterns
   * @param {Object} options
   * @returns {Promise<{attempted:number,terminated:number,errors:Array}>}
   */
  async terminateByPattern (patterns = [], options = {}) {
    if (!patterns.length) {
      return { attempted: 0, terminated: 0, errors: [] };
    }

    const lowered = patterns
      .map(pattern => pattern && pattern.toLowerCase())
      .filter(Boolean);

    const candidates = this.getTrackedProcesses().filter(proc => {
      const name = (proc.name || '').toLowerCase();
      const command = (proc.command || '').toLowerCase();
      return lowered.some(pattern =>
        (name && name.includes(pattern)) ||
        (command && command.includes(pattern))
      );
    });

    const candidatePids = candidates.map(proc => proc.pid);
    return await this.terminatePids(candidatePids, options);
  }
}

module.exports = SafeProcessManager;
