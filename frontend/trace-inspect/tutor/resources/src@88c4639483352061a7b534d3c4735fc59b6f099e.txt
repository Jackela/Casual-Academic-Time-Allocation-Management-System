import { expect, type Locator, type Page, type APIResponse } from '@playwright/test';

export async function waitForVisible(locator: Locator, timeout = 10000): Promise<void> {
  await expect(locator).toBeVisible({ timeout });
}

export async function waitForEnabled(locator: Locator, timeout = 10000): Promise<void> {
  await expect(locator).toBeEnabled({ timeout });
}

export async function waitForToastSuccess(page: Page, timeout = 8000): Promise<void> {
  const toast = page.getByTestId('toast-success').first().or(page.getByTestId('toast').filter({ hasText: /success|created|updated/i }));
  await expect(toast).toBeVisible({ timeout });
}

export async function waitForToastGone(page: Page, timeout = 8000): Promise<void> {
  const stack = page.getByTestId('toast-stack');
  await expect(stack).toBeHidden({ timeout });
}

export function waitForRoute(
  page: Page,
  opts: { method: string; pathPart: string; status?: number; timeoutMs?: number }
): Promise<APIResponse> {
  const { method, pathPart, status, timeoutMs = 15000 } = opts;
  return page.waitForResponse(
    (res) => {
      try {
        const req = res.request();
        const urlOk = req.url().includes(pathPart);
        const methodOk = req.method().toUpperCase() === method.toUpperCase();
        const statusOk = typeof status === 'number' ? res.status() === status : true;
        return urlOk && methodOk && statusOk;
      } catch {
        return false;
      }
    },
    { timeout: timeoutMs }
  );
}

export async function waitForIdleAfter(page: Page, action: () => Promise<void>, idleMs = 250): Promise<void> {
  await action();
  // Small network idle heuristic for UI transitions; not a sleep â€“ relies on stable expectations above
  await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => undefined);
  await page.waitForTimeout(idleMs);
}

// App readiness: wait for role-specific shell where available
export async function waitForAppReady(page: Page, _role: 'ADMIN'|'LECTURER'|'TUTOR', timeout = 15000): Promise<void> {
  await page.waitForLoadState('domcontentloaded').catch(() => undefined);
  await page.waitForLoadState('networkidle').catch(() => undefined);

  // Single-timeout, combined locator per SPA best practices
  const shell = page.locator('[data-testid="app-ready"], [data-testid="app-title"], [data-testid="dashboard-nav"], [data-testid="dashboard-main"]').first();
  await expect(shell).toBeVisible({ timeout });
  // Optional: wait for first whoami/profile to succeed, but don't block if app doesn't call it
  await page.waitForResponse(
    (resp) => {
      try {
        const req = resp.request();
        return (
          req.method() === 'GET' &&
          /\/api\/(auth\/whoami|users\/me|me)\b/.test(resp.url()) &&
          resp.ok()
        );
      } catch { return false; }
    },
    { timeout }
  ).catch(() => undefined);
}

// Optional readiness: resolve on first OK whoami-like response
export async function waitForWhoAmI(page: Page, timeout = 8000): Promise<void> {
  await page.waitForResponse(
    (resp) => {
      try {
        const ok = resp.ok();
        const req = resp.request();
        const isGet = req.method().toUpperCase() === 'GET';
        const url = resp.url();
        return ok && isGet && /\/api\/(auth\/whoami|users\/me|me)\b/.test(url);
      } catch { return false; }
    },
    { timeout }
  );
}

// Admin Users page readiness: any of key elements present
export async function waitForAdminUsersReady(page: Page, timeout = 15000): Promise<void> {
  // Combined sentinel: prefer explicit route marker; fall back to table/create button visibility
  const route = page.locator('[data-testid="admin-users-ready"], [data-testid="admin-users-table"], [data-testid="admin-user-create-btn"]').first();
  await expect(route).toBeVisible({ timeout });
}
