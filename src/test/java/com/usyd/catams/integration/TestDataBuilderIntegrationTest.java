package com.usyd.catams.integration;

import com.usyd.catams.entity.Course;
import com.usyd.catams.entity.Timesheet;
import com.usyd.catams.entity.User;
import com.usyd.catams.enums.ApprovalStatus;
import com.usyd.catams.enums.UserRole;
import com.usyd.catams.repository.CourseRepository;
import com.usyd.catams.repository.TimesheetRepository;
import com.usyd.catams.repository.UserRepository;
import com.usyd.catams.testdata.TestDataBuilder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.*;

/**
 * Integration test for TestDataBuilder validation with create-drop DDL strategy.
 * 
 * This test validates that:
 * - TestDataBuilder creates valid domain aggregates  
 * - Builders respect domain invariants and business rules
 * - Entity persistence works correctly with create-drop schema
 * - Repository operations work with test data
 * - Data isolation is maintained between tests
 * 
 * @author Backend-Data Agent
 */
@SpringBootTest
@ActiveProfiles("test")
@Transactional
class TestDataBuilderIntegrationTest {

    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private CourseRepository courseRepository;
    
    @Autowired
    private TimesheetRepository timesheetRepository;

    @BeforeEach
    void clearDatabase() {
        // Ensure clean database state
        timesheetRepository.deleteAll();
        courseRepository.deleteAll();
        userRepository.deleteAll();
    }

    @Nested
    @DisplayName("User Entity Validation")
    class UserEntityValidation {

        @Test
        @DisplayName("Should create valid Tutor user with domain invariants")
        void shouldCreateValidTutorWithDomainInvariants() {
            // Given
            User tutor = TestDataBuilder.aTutor()
                .withId(null) // Let JPA generate ID
                .withEmail("tutor@test.usyd.edu.au")
                .withName("John Smith")
                .build();

            // When
            User savedTutor = userRepository.save(tutor);

            // Then
            assertThat(savedTutor).isNotNull();
            assertThat(savedTutor.getId()).isNotNull(); // ID generated by JPA
            assertThat(savedTutor.getRole()).isEqualTo(UserRole.TUTOR);
            assertThat(savedTutor.getEmail()).isEqualTo("tutor@test.usyd.edu.au");
            assertThat(savedTutor.getName()).isEqualTo("John Smith");
            assertThat(savedTutor.getFirstName()).isEqualTo("John");
            assertThat(savedTutor.getLastName()).isEqualTo("Smith");
            assertThat(savedTutor.isActive()).isTrue();
            assertThat(savedTutor.getHashedPassword()).isNotBlank();
            assertThat(savedTutor.getCreatedAt()).isNotNull();
            assertThat(savedTutor.getUpdatedAt()).isNotNull();
        }

        @Test
        @DisplayName("Should create valid Lecturer user with domain invariants")
        void shouldCreateValidLecturerWithDomainInvariants() {
            // Given
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("lecturer@test.usyd.edu.au")
                .withName("Dr. Jane Doe")
                .build();

            // When
            User savedLecturer = userRepository.save(lecturer);

            // Then
            assertThat(savedLecturer).isNotNull();
            assertThat(savedLecturer.getRole()).isEqualTo(UserRole.LECTURER);
            assertThat(savedLecturer.getEmail()).isEqualTo("lecturer@test.usyd.edu.au");
            assertThat(savedLecturer.getName()).isEqualTo("Dr. Jane Doe");
            assertThat(savedLecturer.isActive()).isTrue();
        }

        @Test
        @DisplayName("Should create valid Admin user with domain invariants")
        void shouldCreateValidAdminWithDomainInvariants() {
            // Given
            User admin = TestDataBuilder.anAdmin()
                .withId(null)
                .withEmail("admin@test.usyd.edu.au")
                .withName("System Admin")
                .build();

            // When
            User savedAdmin = userRepository.save(admin);

            // Then
            assertThat(savedAdmin).isNotNull();
            assertThat(savedAdmin.getRole()).isEqualTo(UserRole.ADMIN);
            assertThat(savedAdmin.getEmail()).isEqualTo("admin@test.usyd.edu.au");
            assertThat(savedAdmin.isActive()).isTrue();
        }

        @Test
        @DisplayName("Should enforce unique email constraint")
        void shouldEnforceUniqueEmailConstraint() {
            // Given
            User firstUser = TestDataBuilder.aTutor()
                .withId(null)
                .withEmail("duplicate@test.usyd.edu.au")
                .withName("First User")
                .build();
            
            User secondUser = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("duplicate@test.usyd.edu.au")
                .withName("Second User")
                .build();

            // When
            userRepository.save(firstUser);

            // Then
            assertThatThrownBy(() -> {
                userRepository.save(secondUser);
                userRepository.flush(); // Force constraint check
            }).isInstanceOf(Exception.class);
        }
    }

    @Nested
    @DisplayName("Course Entity Validation")
    class CourseEntityValidation {

        @Test
        @DisplayName("Should create valid Course with domain invariants")
        void shouldCreateValidCourseWithDomainInvariants() {
            // Given - Create lecturer first
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("lecturer@course.test")
                .withName("Dr. Course Lecturer")
                .build();
            User savedLecturer = userRepository.save(lecturer);

            Course course = TestDataBuilder.aCourse()
                .withId(null)
                .withCode("COMP3001")
                .withName("Advanced Software Engineering")
                .withSemester("2025S1")
                .withLecturer(savedLecturer)
                .withBudgetAllocated(new BigDecimal("25000.00"))
                .withBudgetUsed(new BigDecimal("5000.00"))
                .build();

            // When
            Course savedCourse = courseRepository.save(course);

            // Then
            assertThat(savedCourse).isNotNull();
            assertThat(savedCourse.getId()).isNotNull();
            assertThat(savedCourse.getCode()).isEqualTo("COMP3001");
            assertThat(savedCourse.getName()).isEqualTo("Advanced Software Engineering");
            assertThat(savedCourse.getSemester()).isEqualTo("2025S1");
            assertThat(savedCourse.getLecturerId()).isEqualTo(savedLecturer.getId());
            assertThat(savedCourse.getBudgetAllocated()).isEqualTo(new BigDecimal("25000.00"));
            assertThat(savedCourse.getBudgetUsed()).isEqualTo(new BigDecimal("5000.00"));
            assertThat(savedCourse.getIsActive()).isTrue();
            assertThat(savedCourse.getCreatedAt()).isNotNull();
            assertThat(savedCourse.getUpdatedAt()).isNotNull();
        }

        @Test
        @DisplayName("Should enforce CourseCode value object validation")
        void shouldEnforceCourseCodeValueObjectValidation() {
            // Given - Create lecturer first
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("lecturer@invalid.test")
                .build();
            User savedLecturer = userRepository.save(lecturer);

            // When/Then - Invalid course codes should be rejected
            assertThatThrownBy(() -> {
                Course invalidCourse = TestDataBuilder.aCourse()
                    .withId(null)
                    .withCode("invalid-code") // Invalid format
                    .withLecturer(savedLecturer)
                    .build();
            }).isInstanceOf(Exception.class);
        }
    }

    @Nested
    @DisplayName("Timesheet Entity Validation")
    class TimesheetEntityValidation {

        private User savedTutor;
        private Course savedCourse;

        @BeforeEach
        void setupTimesheetDependencies() {
            // Create required entities
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("lecturer@timesheet.test")
                .build();
            User savedLecturer = userRepository.save(lecturer);

            savedTutor = TestDataBuilder.aTutor()
                .withId(null)
                .withEmail("tutor@timesheet.test")
                .build();
            savedTutor = userRepository.save(savedTutor);

            savedCourse = TestDataBuilder.aCourse()
                .withId(null)
                .withCode("COMP2001")
                .withLecturer(savedLecturer)
                .build();
            savedCourse = courseRepository.save(savedCourse);
        }

        @Test
        @DisplayName("Should create valid Draft Timesheet with domain invariants")
        void shouldCreateValidDraftTimesheetWithDomainInvariants() {
            // Given
            Timesheet timesheet = TestDataBuilder.aDraftTimesheet()
                .withId(null)
                .withTutor(savedTutor)
                .withCourseId(savedCourse.getId())
                .withWeekStartDate(LocalDate.now().minusWeeks(1).with(java.time.DayOfWeek.MONDAY))
                .withHours(new BigDecimal("15.5"))
                .withHourlyRate(new BigDecimal("48.00"))
                .withDescription("Tutorial sessions and marking")
                .withCreatedBy(savedTutor.getId())
                .build();

            // When
            Timesheet savedTimesheet = timesheetRepository.save(timesheet);

            // Then
            assertThat(savedTimesheet).isNotNull();
            assertThat(savedTimesheet.getId()).isNotNull();
            assertThat(savedTimesheet.getTutorId()).isEqualTo(savedTutor.getId());
            assertThat(savedTimesheet.getCourseId()).isEqualTo(savedCourse.getId());
            assertThat(savedTimesheet.getWeekStartDate().getDayOfWeek()).isEqualTo(java.time.DayOfWeek.MONDAY);
            assertThat(savedTimesheet.getHours()).isEqualTo(new BigDecimal("15.5"));
            assertThat(savedTimesheet.getHourlyRate()).isEqualTo(new BigDecimal("48.00"));
            assertThat(savedTimesheet.getDescription()).isEqualTo("Tutorial sessions and marking");
            assertThat(savedTimesheet.getStatus()).isEqualTo(ApprovalStatus.DRAFT);
            assertThat(savedTimesheet.getCreatedBy()).isEqualTo(savedTutor.getId());
            assertThat(savedTimesheet.getCreatedAt()).isNotNull();
            assertThat(savedTimesheet.getUpdatedAt()).isNotNull();
        }

        @Test
        @DisplayName("Should enforce WeekPeriod value object Monday constraint")
        void shouldEnforceWeekPeriodMondayConstraint() {
            // Given - Try to create timesheet with non-Monday start date
            LocalDate nonMondayDate = LocalDate.now().with(java.time.DayOfWeek.WEDNESDAY);

            // When/Then
            assertThatThrownBy(() -> {
                TestDataBuilder.aDraftTimesheet()
                    .withTutor(savedTutor)
                    .withCourseId(savedCourse.getId())
                    .withWeekStartDate(nonMondayDate) // Should throw exception
                    .build();
            }).isInstanceOf(Exception.class);
        }

        @Test
        @DisplayName("Should support approval status transitions")
        void shouldSupportApprovalStatusTransitions() {
            // Given
            Timesheet draftTimesheet = TestDataBuilder.aDraftTimesheet()
                .withId(null)
                .withTutor(savedTutor)
                .withCourseId(savedCourse.getId())
                .build();

            Timesheet pendingTimesheet = TestDataBuilder.aDraftTimesheet()
                .withId(null)
                .withTutor(savedTutor)
                .withCourseId(savedCourse.getId())
                // Use a different week start date to respect unique constraint (tutor, course, week)
                .withWeekStartDate(LocalDate.now().minusWeeks(2).with(java.time.DayOfWeek.MONDAY))
                .asPendingTutorConfirmation()
                .build();

            // When
            Timesheet savedDraft = timesheetRepository.save(draftTimesheet);
            Timesheet savedPending = timesheetRepository.save(pendingTimesheet);

            // Then
            assertThat(savedDraft.getStatus()).isEqualTo(ApprovalStatus.DRAFT);
            assertThat(savedPending.getStatus()).isEqualTo(ApprovalStatus.PENDING_TUTOR_CONFIRMATION);
        }
    }

    @Nested
    @DisplayName("Repository Layer Testing")
    class RepositoryLayerTesting {

        @Test
        @DisplayName("Should perform User repository operations correctly")
        void shouldPerformUserRepositoryOperationsCorrectly() {
            // Given
            User tutor = TestDataBuilder.aTutor()
                .withId(null)
                .withEmail("repo.tutor@test.usyd.edu.au")
                .withName("Repository Test Tutor")
                .build();

            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("repo.lecturer@test.usyd.edu.au")
                .withName("Repository Test Lecturer")
                .build();

            // When
            User savedTutor = userRepository.save(tutor);
            User savedLecturer = userRepository.save(lecturer);

            // Then - Test basic operations
            assertThat(userRepository.findById(savedTutor.getId())).isPresent();
            assertThat(userRepository.findByEmail("repo.tutor@test.usyd.edu.au")).isPresent();
            assertThat(userRepository.existsByEmail("repo.tutor@test.usyd.edu.au")).isTrue();

            // Test role-based queries
            List<User> tutors = userRepository.findByRole(UserRole.TUTOR);
            assertThat(tutors).hasSize(1);
            assertThat(tutors.get(0).getEmail()).isEqualTo("repo.tutor@test.usyd.edu.au");

            List<User> lecturers = userRepository.findByRole(UserRole.LECTURER);
            assertThat(lecturers).hasSize(1);
            assertThat(lecturers.get(0).getEmail()).isEqualTo("repo.lecturer@test.usyd.edu.au");

            // Test active users
            List<User> activeUsers = userRepository.findByIsActive(true);
            assertThat(activeUsers).hasSize(2);
        }

        @Test
        @DisplayName("Should perform Course repository operations correctly")
        void shouldPerformCourseRepositoryOperationsCorrectly() {
            // Given
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("course.lecturer@test.usyd.edu.au")
                .build();
            User savedLecturer = userRepository.save(lecturer);

            Course course = TestDataBuilder.aCourse()
                .withId(null)
                .withCode("REPO1001")
                .withName("Repository Testing Course")
                .withLecturer(savedLecturer)
                .build();

            // When
            Course savedCourse = courseRepository.save(course);

            // Then
            assertThat(courseRepository.findById(savedCourse.getId())).isPresent();
            
            // Test custom queries if they exist
            Optional<Course> foundCourse = courseRepository.findById(savedCourse.getId());
            assertThat(foundCourse).isPresent();
            assertThat(foundCourse.get().getCode()).isEqualTo("REPO1001");
            assertThat(foundCourse.get().getLecturerId()).isEqualTo(savedLecturer.getId());
        }

        @Test
        @DisplayName("Should perform Timesheet repository operations correctly")
        void shouldPerformTimesheetRepositoryOperationsCorrectly() {
            // Given - Setup dependencies
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("timesheet.lecturer@test.usyd.edu.au")
                .build();
            User savedLecturer = userRepository.save(lecturer);

            User tutor = TestDataBuilder.aTutor()
                .withId(null)
                .withEmail("timesheet.tutor@test.usyd.edu.au")
                .build();
            User savedTutor = userRepository.save(tutor);

            Course course = TestDataBuilder.aCourse()
                .withId(null)
                .withCode("TIME1001")
                .withLecturer(savedLecturer)
                .build();
            Course savedCourse = courseRepository.save(course);

            Timesheet timesheet = TestDataBuilder.aDraftTimesheet()
                .withId(null)
                .withTutor(savedTutor)
                .withCourseId(savedCourse.getId())
                .build();

            // When
            Timesheet savedTimesheet = timesheetRepository.save(timesheet);

            // Then
            assertThat(timesheetRepository.findById(savedTimesheet.getId())).isPresent();
            
            Optional<Timesheet> foundTimesheet = timesheetRepository.findById(savedTimesheet.getId());
            assertThat(foundTimesheet).isPresent();
            assertThat(foundTimesheet.get().getTutorId()).isEqualTo(savedTutor.getId());
            assertThat(foundTimesheet.get().getCourseId()).isEqualTo(savedCourse.getId());
            assertThat(foundTimesheet.get().getStatus()).isEqualTo(ApprovalStatus.DRAFT);
        }
    }

    @Nested
    @DisplayName("Data Isolation Validation")
    class DataIsolationValidation {

        @Test
        @DisplayName("Test 1 - Should start with empty database")
        void test1_shouldStartWithEmptyDatabase() {
            // Then - Database should be empty due to @Transactional
            assertThat(userRepository.count()).isZero();
            assertThat(courseRepository.count()).isZero();
            assertThat(timesheetRepository.count()).isZero();

            // Create test data that will be rolled back
            User testUser = TestDataBuilder.aTutor()
                .withId(null)
                .withEmail("isolation.test1@test.usyd.edu.au")
                .build();
            userRepository.save(testUser);
            
            assertThat(userRepository.count()).isEqualTo(1);
        }

        @Test
        @DisplayName("Test 2 - Should not see data from previous test")
        void test2_shouldNotSeeDataFromPreviousTest() {
            // Then - Should not see data from test1 due to transaction isolation
            assertThat(userRepository.count()).isZero();
            assertThat(courseRepository.count()).isZero();
            assertThat(timesheetRepository.count()).isZero();

            // Create different test data
            User testUser = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("isolation.test2@test.usyd.edu.au")
                .build();
            userRepository.save(testUser);
            
            assertThat(userRepository.count()).isEqualTo(1);
        }

        @Test
        @DisplayName("Test 3 - Should confirm clean state continues")
        void test3_shouldConfirmCleanStateContinues() {
            // Then - Confirm isolation continues
            assertThat(userRepository.count()).isZero();
            assertThat(courseRepository.count()).isZero();
            assertThat(timesheetRepository.count()).isZero();
        }
    }

    @Nested
    @DisplayName("Domain Invariant Validation")
    class DomainInvariantValidation {

        @Test
        @DisplayName("Should enforce User domain invariants")
        void shouldEnforceUserDomainInvariants() {
            // Test valid construction
            User validUser = TestDataBuilder.aUser()
                .withEmail("valid@test.usyd.edu.au")
                .withName("Valid User")
                .withRole(UserRole.TUTOR)
                .build();

            assertThat(validUser.hasValidName()).isTrue();
            assertThat(validUser.getEmailValue()).isEqualTo("valid@test.usyd.edu.au");
            assertThat(validUser.isActive()).isTrue();

            // Test domain rule enforcement in constructor
            assertThatThrownBy(() -> {
                new User((String) null, "Test User", "hashedPassword", UserRole.TUTOR);
            }).isInstanceOf(Exception.class);

            assertThatThrownBy(() -> {
                new User("test@example.com", null, "hashedPassword", UserRole.TUTOR);
            }).isInstanceOf(IllegalArgumentException.class);

            assertThatThrownBy(() -> {
                new User("test@example.com", "Test User", null, UserRole.TUTOR);
            }).isInstanceOf(IllegalArgumentException.class);
        }

        @Test
        @DisplayName("Should enforce Course domain invariants")
        void shouldEnforceCourseDomainInvariants() {
            // Given
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("invariant.lecturer@test.usyd.edu.au")
                .build();
            User savedLecturer = userRepository.save(lecturer);

            // Test valid course
            Course validCourse = TestDataBuilder.aCourse()
                .withCode("COMP1001") // Valid format
                .withBudgetAllocated(new BigDecimal("10000.00"))
                .withBudgetUsed(new BigDecimal("5000.00"))
                .withLecturer(savedLecturer)
                .build();

            // Budget used should not exceed budget allocated
            assertThat(validCourse.getBudgetUsed())
                .isLessThanOrEqualTo(validCourse.getBudgetAllocated());
        }

        @Test
        @DisplayName("Should enforce Timesheet domain invariants")
        void shouldEnforceTimesheetDomainInvariants() {
            // Given dependencies
            User lecturer = TestDataBuilder.aLecturer()
                .withId(null)
                .withEmail("timesheet.invariant.lecturer@test.usyd.edu.au")
                .build();
            User savedLecturer = userRepository.save(lecturer);

            User tutor = TestDataBuilder.aTutor()
                .withId(null)
                .withEmail("timesheet.invariant.tutor@test.usyd.edu.au")
                .build();
            User savedTutor = userRepository.save(tutor);

            Course course = TestDataBuilder.aCourse()
                .withId(null)
                .withLecturer(savedLecturer)
                .build();
            Course savedCourse = courseRepository.save(course);

            // Test valid timesheet construction
            Timesheet validTimesheet = TestDataBuilder.aDraftTimesheet()
                .withTutor(savedTutor)
                .withCourseId(savedCourse.getId())
                .withHours(new BigDecimal("20.0")) // Valid hours
                .withHourlyRate(new BigDecimal("45.00")) // Valid rate
                .withWeekStartDate(LocalDate.now().minusWeeks(1).with(java.time.DayOfWeek.MONDAY))
                .build();

            // Validate domain rules
            assertThat(validTimesheet.getHours()).isGreaterThan(BigDecimal.ZERO);
            assertThat(validTimesheet.getHours()).isLessThanOrEqualTo(new BigDecimal("40.0"));
            assertThat(validTimesheet.getHourlyRate()).isGreaterThan(BigDecimal.ZERO);
            assertThat(validTimesheet.getWeekStartDate().getDayOfWeek()).isEqualTo(java.time.DayOfWeek.MONDAY);
        }
    }
}