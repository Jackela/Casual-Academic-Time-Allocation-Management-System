}

// 2. Configure node-gradle
node {
    version.set("20.11.1") // Specify Node.js version
    npmVersion.set("10.2.4") // Specify npm version
    download.set(true) // Auto download and install
}

// 3. Define a task to install Redocly CLI
tasks.register<com.github.gradle.node.npm.task.NpmTask>("installRedocly") {
    group = "Documentation"
    description = "Installs Redocly CLI locally using npm."
    // Install Redocly CLI to the project's local node_modules directory
    args.set(listOf("install", "@redocly/cli@latest"))
}

// 4. Define a task to run Redocly CLI bundle command
tasks.register<com.github.gradle.node.npm.task.NpxTask>("bundleOpenApiSpec") {
    group = "Documentation"
    description = "Bundles the distributed OpenAPI spec into a single file using Redocly CLI."
    
    // Ensure Redocly CLI is already installed
    dependsOn("installRedocly")

    // 'npx redocly bundle path/to/your/main.yaml -o build/docs/api/openapi.yaml'
    command.set("redocly")
    val bundledSpec = layout.buildDirectory.file("docs/api/openapi.yaml")
    args.set(listOf(
        "bundle",
        "docs/openapi.yaml", // Your main entry YAML file
        "--output",
        bundledSpec.get().asFile.absolutePath
    ))
}

// Core: Configure the OpenAPI Generator task
openApiGenerate {
    generatorName.set("java")
    inputSpec.set("$projectDir/docs/openapi.yaml")
    outputDir.set(layout.buildDirectory.dir("generated/openapi").get().asFile.absolutePath)
    apiPackage.set("com.usyd.catams.client.api")
    modelPackage.set("com.usyd.catams.client.model")
    configOptions.set(mapOf(
        "library" to "native",
        "useJakartaEe" to "true",
        "openApiNullable" to "false",
        "sourceFolder" to "src/main/java"
    ))
}

@CacheableTask
abstract class ExtractOpenApiSchemas : DefaultTask() {
    @get:InputFile
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val openApiFile: RegularFileProperty

    @get:OutputDirectory
    abstract val outputDirectory: DirectoryProperty

    @TaskAction
    fun extract() {
        val yaml = org.yaml.snakeyaml.Yaml()
        @Suppress("UNCHECKED_CAST")
        val openApiData = openApiFile.get().asFile.inputStream().use { input ->
            yaml.load<Map<String, Any?>>(input)
        } ?: emptyMap()

        val schemas = (openApiData["components"] as? Map<*, *>)?.get("schemas") as? Map<*, *> ?: emptyMap<Any?, Any?>()
        if (schemas.isEmpty()) {
            logger.info("No component schemas found in ${openApiFile.get().asFile}")
            return
        }

        val outputDir = outputDirectory.get().asFile.apply { mkdirs() }
        val objectMapper = ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT)

        schemas.forEach { (schemaName, schemaData) ->
            val name = schemaName?.toString() ?: return@forEach
            val schemaFile = outputDir.resolve("$name.json")
            schemaFile.writeText(objectMapper.writeValueAsString(schemaData))
            logger.info("Extracted OpenAPI schema: $name")
        }
    }
}

val extractOpenApiSchemas by tasks.register<ExtractOpenApiSchemas>("extractOpenApiSchemas") {
    group = "OpenAPI"
    description = "Extracts component schemas from openapi.yaml into individual JSON files."
    openApiFile.set(layout.projectDirectory.file("docs/openapi.yaml"))
    outputDirectory.set(layout.buildDirectory.dir("resources/test/openapi/schemas"))
}

// 2. Create a custom Gradle task to run ContractGenerator
tasks.register<JavaExec>("generateSemanticContract") {
    group = "Documentation"
    description = "Generates a machine-readable JSON file of the project's semantic contract."
    
    // Specify the classpath for our generator tool
    classpath = configurations.getByName("contractGenerator")
    
    // Specify the compiled output directory containing ContractGenerator.java
    // Assuming you place this utility class in a separate 'generator' source set, or compile it with the main code
    classpath += sourceSets.main.get().output
    
    // Specify the main class to run
    mainClass.set("com.usyd.catams.tools.ContractGenerator")
    
    // Pass arguments, such as source file directory and output file path
    val sourceDir = layout.projectDirectory.dir("src/main/java")
    val contractOutput = layout.buildDirectory.file("docs/api/contract.json")
    args(
        "--source", sourceDir.asFile.absolutePath,
        "--output", contractOutput.get().asFile.absolutePath
    )
    
    // Ensure output directory exists
    doFirst {
        contractOutput.get().asFile.parentFile.mkdirs()
    }
}


tasks.withType<Test>().configureEach {
    dependsOn(extractOpenApiSchemas) // Ensure schemas are extracted before tests run
    finalizedBy(tasks.jacocoTestReport)
}

val integrationTest by tasks.registering(Test::class) {
    description = "Runs Spring integration tests with Testcontainers profile."
    group = "verification"
    testClassesDirs = sourceSets["test"].output.classesDirs
    classpath = sourceSets["test"].runtimeClasspath
    useJUnitPlatform()
    shouldRunAfter(tasks.test)
    include("**/integration/**", "**/*IntegrationTest.class", "**/*IT.class")
    systemProperty("spring.profiles.active", "integration-test")
}

tasks.check {
    dependsOn(integrationTest)
}

jacoco {
    toolVersion = "0.8.10"
}

tasks.jacocoTestReport {
    dependsOn(tasks.test)
    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}

tasks.withType<ProcessResources> {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

sourceSets {
    main {
        java {
            // Core: Add generated sources to the main source set
            srcDir(layout.buildDirectory.dir("generated/openapi/src/main/java"))
            srcDir(layout.buildDirectory.dir("generated-contracts/java"))
        }
        resources {
            srcDirs("src/main/resources")
        }
    }
    test {
        resources {
            srcDirs("src/test/java", "src/test/resources", "docs")
            include("**/*.yaml", "**/*.yml", "**/*.md", "**/*.feature")
            exclude("**/*.java", "**/*.kt")
        }
    }
}

tasks.named<BootRun>("bootRun") {
    val activeProfiles = System.getenv("SPRING_PROFILES_ACTIVE") ?: ""
    val disableDevtools = System.getenv("DISABLE_DEVTOOLS") == "1" ||
        activeProfiles.split(',').map { it.trim().lowercase() }.any { it == "e2e" || it == "e2e-local" }
    systemProperty("spring.devtools.restart.enabled", "false")
    systemProperty("spring.devtools.livereload.enabled", "false")
    systemProperty("spring.devtools.add-properties", "false")
    doFirst {
        if (disableDevtools) {
            classpath = classpath.filter { !it.name.contains("spring-boot-devtools") }
        }
    }
}








