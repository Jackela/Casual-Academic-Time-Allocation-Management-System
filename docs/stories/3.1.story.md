# Story 3.1: Implement Core Dashboard Functionality for All Roles

## Story Information
- **Epic:** 3 - Data Visualization & Final Audit
- **Story:** 3.1
- **Title:** Implement Core Dashboard Functionality for All Roles
- **Status:** Ready for Development
- **Assigned to:** Development Agent
- **Story Points:** [To be estimated]

## Story Statement
**As a** user (TUTOR, LECTURER, or ADMIN),
**I want** a personalized dashboard that provides a quick summary of my key metrics and pending tasks,
**so that** I can efficiently understand the current state of my work and make informed decisions about my time allocation.

This story implements the foundational dashboard service that aggregates role-specific data from existing services, providing each user role with relevant summaries through the `GET /api/dashboard/summary` endpoint as specified in our OpenAPI contract.

## Acceptance Criteria
- **AC1:** An authenticated **TUTOR** calling `GET /api/dashboard/summary` receives a summary of their own timesheets (e.g., total hours, total pay, pending status).
- **AC2:** An authenticated **LECTURER** calling the endpoint receives a summary related to the courses they manage (e.g., total pending approvals for their courses, course budget usage).
- **AC3:** An authenticated **ADMIN** calling the endpoint receives a system-wide summary (e.g., total number of users, total budget usage across all courses).
- **AC4:** The implementation requires creating a new `DashboardService` that aggregates data from other services like `TimesheetService` and `CourseService`.
- **AC5:** The API response for each role must strictly conform to the schemas defined in `openapi.yaml`.

## Dev Notes

### Story Context and Dependencies
Story 3.1 marks the beginning of Epic 3 (Data Visualization & Final Audit), building upon the completed Epic 2 foundation:
- **Existing Infrastructure**: Full timesheet management system with approval workflows [Epic 1 & 2]
- **Available Services**: TimesheetService, UserService, ApprovalService, and supporting data access layer
- **Authentication**: JWT-based RBAC system with TUTOR, LECTURER, ADMIN roles
- **Data Foundation**: Comprehensive timesheet, user, and course data for aggregation

### OpenAPI Contract Analysis
Based on `docs/openapi.yaml` lines 968-1126, the `/api/dashboard/summary` endpoint specification defines:

**Endpoint Definition**:
- **Path**: `GET /api/dashboard/summary`
- **Authentication**: Bearer JWT token required
- **Response Schema**: `DashboardSummaryResponse` [Lines 1635-1677]

**Role-Based Access Control**:
- **TUTOR**: Personal timesheet summary only
- **LECTURER**: Course-level summaries for managed courses  
- **ADMIN**: System-wide administrative summary

**Query Parameters** [Lines 991-1019]:
- `courseId`: Filter by specific course (LECTURER/ADMIN only)
- `semester`: Filter by semester (YYYY-S format)
- `startDate`/`endDate`: Custom date range for metrics calculation

**Response Structure** [Lines 1635-1872]:
```yaml
DashboardSummaryResponse:
  totalTimesheets: integer
  pendingApprovals: integer  
  totalHours: decimal
  totalPay: decimal
  budgetUsage: BudgetUsage (LECTURER/ADMIN only)
  recentActivities: RecentActivity[]
  pendingItems: PendingItem[]
  workloadAnalysis: WorkloadAnalysis
```

### Architecture Integration Strategy

**Service Layer Design**:
Following established project patterns [Source: docs/architecture/project-structure.md], the implementation requires:

```java
// New Service Interface
src/main/java/com/usyd/catams/service/DashboardService.java

// New Service Implementation  
src/main/java/com/usyd/catams/service/impl/DashboardServiceImpl.java

// New Controller
src/main/java/com/usyd/catams/controller/DashboardController.java

// New Response DTOs
src/main/java/com/usyd/catams/dto/response/DashboardSummary.java
src/main/java/com/usyd/catams/dto/response/BudgetUsage.java
src/main/java/com/usyd/catams/dto/response/RecentActivity.java
src/main/java/com/usyd/catams/dto/response/PendingItem.java
src/main/java/com/usyd/catams/dto/response/WorkloadAnalysis.java
```

**Data Aggregation Strategy**:
The DashboardService will aggregate data from existing services without duplicating business logic:

1. **TimesheetService Integration**: Leverage existing queries for timesheet metrics
2. **UserService Integration**: Access user and role information  
3. **ApprovalService Integration**: Retrieve pending approval counts and history
4. **Repository Queries**: Efficient data aggregation using existing repositories

### Role-Specific Implementation Logic

**TUTOR Dashboard Logic** [AC1]:
```java
/**
 * Generate TUTOR-specific dashboard summary.
 * Aggregates personal timesheet data for the authenticated tutor.
 */
public DashboardSummary getTutorDashboard(Long tutorId, DateRange dateRange) {
    // Aggregate tutor's own timesheets only
    List<Timesheet> tutorTimesheets = timesheetService.getTimesheetsByTutor(tutorId, dateRange);
    
    return DashboardSummary.builder()
        .totalTimesheets(tutorTimesheets.size())
        .pendingApprovals(countPendingTimesheets(tutorTimesheets))
        .totalHours(calculateTotalHours(tutorTimesheets))
        .totalPay(calculateTotalPay(tutorTimesheets))
        .budgetUsage(null) // TUTORs don't see budget information
        .recentActivities(getRecentActivitiesForTutor(tutorId))
        .pendingItems(getPendingItemsForTutor(tutorId))
        .workloadAnalysis(getWorkloadAnalysisForTutor(tutorId))
        .build();
}
```

**LECTURER Dashboard Logic** [AC2]:
```java
/**
 * Generate LECTURER-specific dashboard summary.
 * Aggregates data for courses managed by the lecturer.
 */
public DashboardSummary getLecturerDashboard(Long lecturerId, Optional<Long> courseId, DateRange dateRange) {
    // Get courses managed by this lecturer
    List<Course> managedCourses = courseService.getCoursesByLecturer(lecturerId);
    
    if (courseId.isPresent()) {
        // Filter to specific course if provided
        managedCourses = managedCourses.stream()
            .filter(course -> course.getId().equals(courseId.get()))
            .collect(Collectors.toList());
    }
    
    // Aggregate timesheets for managed courses
    List<Timesheet> courseTimesheets = timesheetService.getTimesheetsByCourses(
        managedCourses.stream().map(Course::getId).collect(Collectors.toList()),
        dateRange
    );
    
    return DashboardSummary.builder()
        .totalTimesheets(courseTimesheets.size())
        .pendingApprovals(countPendingLecturerApprovals(courseTimesheets))
        .totalHours(calculateTotalHours(courseTimesheets))
        .totalPay(calculateTotalPay(courseTimesheets))
        .budgetUsage(calculateBudgetUsage(managedCourses, courseTimesheets))
        .recentActivities(getRecentActivitiesForCourses(managedCourses))
        .pendingItems(getPendingItemsForLecturer(lecturerId))
        .workloadAnalysis(getWorkloadAnalysisForCourses(managedCourses))
        .build();
}
```

**ADMIN Dashboard Logic** [AC3]:
```java
/**
 * Generate ADMIN-specific dashboard summary.
 * Provides system-wide administrative metrics.
 */
public DashboardSummary getAdminDashboard(Optional<Long> courseId, DateRange dateRange) {
    // System-wide data aggregation
    List<Timesheet> allTimesheets = courseId.isPresent() 
        ? timesheetService.getTimesheetsByCourse(courseId.get(), dateRange)
        : timesheetService.getAllTimesheets(dateRange);
    
    return DashboardSummary.builder()
        .totalTimesheets(allTimesheets.size())
        .pendingApprovals(countSystemWidePendingApprovals())
        .totalHours(calculateTotalHours(allTimesheets))
        .totalPay(calculateTotalPay(allTimesheets))
        .budgetUsage(calculateSystemWideBudgetUsage(dateRange))
        .recentActivities(getSystemWideRecentActivities())
        .pendingItems(getPendingItemsForAdmin())
        .workloadAnalysis(getSystemWideWorkloadAnalysis())
        .build();
}
```

### Controller Implementation Strategy

**DashboardController Design**:
Following RESTful principles and existing controller patterns [Source: docs/architecture/coding-standards.md]:

```java
@RestController
@RequestMapping("/api/dashboard")
@PreAuthorize("hasRole('TUTOR') or hasRole('LECTURER') or hasRole('ADMIN')")
public class DashboardController {
    
    private final DashboardService dashboardService;
    
    /**
     * Get dashboard summary based on authenticated user's role.
     * 
     * @param courseId Optional course filter (LECTURER/ADMIN only)
     * @param semester Optional semester filter  
     * @param startDate Optional start date for metrics
     * @param endDate Optional end date for metrics
     * @param authentication Current user authentication
     * @return Role-appropriate dashboard summary
     */
    @GetMapping("/summary")
    public ResponseEntity<DashboardSummaryResponse> getDashboardSummary(
            @RequestParam(value = "courseId", required = false) Long courseId,
            @RequestParam(value = "semester", required = false) String semester,
            @RequestParam(value = "startDate", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam(value = "endDate", required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate,
            Authentication authentication) {
        
        UserPrincipal user = (UserPrincipal) authentication.getPrincipal();
        DateRange dateRange = buildDateRange(startDate, endDate, semester);
        
        DashboardSummaryResponse summary = dashboardService.getDashboardSummary(
            user.getId(), 
            user.getRole(), 
            Optional.ofNullable(courseId),
            dateRange
        );
        
        return ResponseEntity.ok(summary);
    }
}
```

### Data Transfer Object Design

Following OpenAPI specification requirements [AC5], all DTOs must match the defined schemas:

**DashboardSummaryResponse** [Lines 1635-1677]:
```java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class DashboardSummaryResponse {
    
    @NotNull
    private Integer totalTimesheets;
    
    @NotNull  
    private Integer pendingApprovals;
    
    @NotNull
    @DecimalMin("0.0")
    private BigDecimal totalHours;
    
    @NotNull
    @DecimalMin("0.0") 
    private BigDecimal totalPay;
    
    // Only populated for LECTURER/ADMIN roles
    private BudgetUsage budgetUsage;
    
    @NotNull
    private List<RecentActivity> recentActivities;
    
    @NotNull
    private List<PendingItem> pendingItems;
    
    @NotNull
    private WorkloadAnalysis workloadAnalysis;
    
    // constructors, getters, setters...
}
```

**BudgetUsage** [Lines 1679-1708]:
```java
public class BudgetUsage {
    
    @NotNull
    @DecimalMin("0.0")
    private BigDecimal totalBudget;
    
    @NotNull
    @DecimalMin("0.0")
    private BigDecimal usedBudget;
    
    @NotNull
    @DecimalMin("0.0")
    private BigDecimal remainingBudget;
    
    @NotNull
    @DecimalMin("0.0")
    @DecimalMax("100.0")
    private BigDecimal utilizationPercentage;
    
    // constructors, getters, setters...
}
```

### Repository and Database Considerations

**Efficient Data Aggregation**:
Leverage existing repository infrastructure with new aggregation queries:

```java
// Extend TimesheetRepository with aggregation methods
public interface TimesheetRepository extends JpaRepository<Timesheet, Long> {
    
    // Existing methods from previous stories...
    
    /**
     * Get timesheet aggregation data for dashboard.
     * Returns summary metrics for efficient dashboard rendering.
     */
    @Query("""
        SELECT new com.usyd.catams.dto.TimesheetSummaryData(
            COUNT(t), 
            SUM(t.hours), 
            SUM(t.totalPay),
            COUNT(CASE WHEN t.status = 'PENDING_LECTURER_APPROVAL' THEN 1 END)
        )
        FROM Timesheet t 
        WHERE t.tutorId = :tutorId 
        AND t.weekStartDate BETWEEN :startDate AND :endDate
        """)
    TimesheetSummaryData findTimesheetSummaryByTutor(
        @Param("tutorId") Long tutorId,
        @Param("startDate") LocalDate startDate, 
        @Param("endDate") LocalDate endDate
    );
    
    /**
     * Get timesheet aggregation data for courses managed by a lecturer.
     */
    @Query("""
        SELECT new com.usyd.catams.dto.TimesheetSummaryData(
            COUNT(t), 
            SUM(t.hours), 
            SUM(t.totalPay),
            COUNT(CASE WHEN t.status = 'PENDING_LECTURER_APPROVAL' THEN 1 END)
        )
        FROM Timesheet t 
        WHERE t.courseId IN :courseIds
        AND t.weekStartDate BETWEEN :startDate AND :endDate
        """)
    TimesheetSummaryData findTimesheetSummaryByCourses(
        @Param("courseIds") List<Long> courseIds,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate
    );
}
```

**Performance Optimization**:
- Use aggregation queries to minimize data transfer
- Cache frequently accessed course-lecturer mappings
- Implement pagination for activity feeds
- Add database indexes for dashboard-specific queries

### Security and Authorization Implementation

**Role-Based Data Access**:
Strict enforcement of role-based data access controls:

```java
@Service
@Transactional(readOnly = true)
public class DashboardServiceImpl implements DashboardService {
    
    @Override
    public DashboardSummaryResponse getDashboardSummary(Long userId, UserRole role, 
                                                       Optional<Long> courseId, DateRange dateRange) {
        switch (role) {
            case TUTOR:
                // TUTORs can only see their own data
                if (courseId.isPresent()) {
                    throw new ValidationException("TUTORs cannot filter by course");
                }
                return getTutorDashboard(userId, dateRange);
                
            case LECTURER:
                // LECTURERs can only see data for courses they manage
                validateLecturerAccess(userId, courseId);
                return getLecturerDashboard(userId, courseId, dateRange);
                
            case ADMIN:
                // ADMINs have system-wide access
                return getAdminDashboard(courseId, dateRange);
                
            default:
                throw new AuthenticationException("Invalid user role");
        }
    }
    
    private void validateLecturerAccess(Long lecturerId, Optional<Long> courseId) {
        if (courseId.isPresent()) {
            boolean hasAccess = courseService.isLecturerForCourse(lecturerId, courseId.get());
            if (!hasAccess) {
                throw new AuthorizationException("Lecturer does not have access to this course");
            }
        }
    }
}
```

### Error Handling and Validation

**Comprehensive Error Coverage**:
Following established error handling patterns [Source: docs/architecture/coding-standards.md]:

**HTTP Status Codes**:
- **200 OK**: Successful dashboard data retrieval
- **400 Bad Request**: Invalid date range or semester format
- **401 Unauthorized**: Missing or invalid JWT token
- **403 Forbidden**: Role-based access violation (e.g., TUTOR requesting course filter)
- **404 Not Found**: Course not found (when courseId provided)
- **500 Internal Server Error**: System error during data aggregation

**Input Validation**:
```java
/**
 * Validate and build date range for dashboard queries.
 */
private DateRange buildDateRange(LocalDate startDate, LocalDate endDate, String semester) {
    if (semester != null) {
        // Validate semester format: YYYY-S
        if (!semester.matches("^\\d{4}-[12]$")) {
            throw new ValidationException("Invalid semester format. Use YYYY-S (e.g., 2025-1)");
        }
        return DateRange.fromSemester(semester);
    }
    
    if (startDate != null && endDate != null) {
        if (startDate.isAfter(endDate)) {
            throw new ValidationException("Start date cannot be after end date");
        }
        return DateRange.of(startDate, endDate);
    }
    
    // Default to current semester
    return DateRange.currentSemester();
}
```

### Integration with Existing Services

**Service Dependency Strategy**:
Leverage existing services without creating circular dependencies:

```java
@Service  
@RequiredArgsConstructor
public class DashboardServiceImpl implements DashboardService {
    
    // Existing services for data aggregation
    private final TimesheetService timesheetService;
    private final UserService userService;
    private final CourseService courseService;
    private final ApprovalService approvalService;
    
    // Direct repository access for efficient aggregation
    private final TimesheetRepository timesheetRepository;
    private final ApprovalRepository approvalRepository;
    
    // Inject authentication context
    private final SecurityContext securityContext;
}
```

**Data Consistency**:
- All dashboard data reflects real-time state from authoritative services
- No dashboard-specific data storage (pure aggregation service)
- Consistent business rule enforcement across all data sources

### Testing Strategy

**Comprehensive Test Coverage**:
Following established testing patterns [Source: docs/architecture/coding-standards.md]:

**Unit Tests** - Target 80%+ coverage:
```java
@ExtendWith(MockitoExtension.class)
class DashboardServiceImplTest {
    
    @Mock
    private TimesheetService timesheetService;
    
    @Mock
    private CourseService courseService;
    
    @InjectMocks
    private DashboardServiceImpl dashboardService;
    
    @Test
    @DisplayName("TUTOR dashboard returns personal timesheet summary")
    void shouldReturnTutorDashboard() {
        // Given
        Long tutorId = 123L;
        DateRange dateRange = DateRange.currentSemester();
        List<Timesheet> tutorTimesheets = createMockTutorTimesheets();
        
        when(timesheetService.getTimesheetsByTutor(tutorId, dateRange))
            .thenReturn(tutorTimesheets);
        
        // When
        DashboardSummaryResponse result = dashboardService.getDashboardSummary(
            tutorId, UserRole.TUTOR, Optional.empty(), dateRange);
        
        // Then
        assertThat(result.getTotalTimesheets()).isEqualTo(5);
        assertThat(result.getTotalHours()).isEqualTo(new BigDecimal("42.5"));
        assertThat(result.getBudgetUsage()).isNull(); // TUTORs don't see budget
        verify(timesheetService).getTimesheetsByTutor(tutorId, dateRange);
    }
    
    @Test
    @DisplayName("LECTURER cannot access course they don't manage")
    void shouldThrowExceptionWhenLecturerAccessesUnauthorizedCourse() {
        // Given
        Long lecturerId = 999L;
        Long unauthorizedCourseId = 456L;
        
        when(courseService.isLecturerForCourse(lecturerId, unauthorizedCourseId))
            .thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> dashboardService.getDashboardSummary(
            lecturerId, UserRole.LECTURER, Optional.of(unauthorizedCourseId), DateRange.currentSemester()))
            .isInstanceOf(AuthorizationException.class)
            .hasMessage("Lecturer does not have access to this course");
    }
}
```

**Integration Tests**:
```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Testcontainers
class DashboardControllerIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("catams_test")
            .withUsername("test")
            .withPassword("test");
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    @DisplayName("TUTOR can retrieve dashboard summary")
    void shouldReturnTutorDashboardSummary() {
        // Given
        String jwtToken = authenticateAsUser("tutor@university.edu.au", UserRole.TUTOR);
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(jwtToken);
        HttpEntity<Void> request = new HttpEntity<>(headers);
        
        // When
        ResponseEntity<DashboardSummaryResponse> response = restTemplate.exchange(
            "/api/dashboard/summary", HttpMethod.GET, request, DashboardSummaryResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getTotalTimesheets()).isGreaterThanOrEqualTo(0);
        assertThat(response.getBody().getBudgetUsage()).isNull(); // TUTORs don't see budget
    }
}
```

### Performance and Scalability Considerations

**Optimization Strategies**:
- **Query Optimization**: Use aggregation queries to minimize data transfer
- **Caching**: Cache course-lecturer mappings and user roles
- **Lazy Loading**: Load recent activities and pending items on-demand
- **Database Indexing**: Add composite indexes for dashboard queries

**Scalability Design**:
- Service methods designed for horizontal scaling
- Database queries optimized for concurrent access
- No session state dependencies
- Efficient pagination for large datasets

## Tasks/Subtasks

### Task 1: Create DashboardService Interface and Core DTOs (AC4, AC5)
- [x] Create DashboardService interface with role-based summary methods
- [x] Implement DashboardSummaryResponse DTO matching OpenAPI schema
- [x] Create supporting DTOs: BudgetUsage, RecentActivity, PendingItem, WorkloadAnalysis
- [x] Add proper validation annotations following coding standards
- [x] Ensure all DTOs support JSON serialization with proper null handling

### Task 2: Implement TUTOR Dashboard Logic (AC1)
- [ ] Implement getTutorDashboard() method in DashboardServiceImpl
- [ ] Add TimesheetRepository aggregation queries for TUTOR data
- [ ] Create getRecentActivitiesForTutor() method
- [ ] Create getPendingItemsForTutor() method  
- [ ] Create getWorkloadAnalysisForTutor() method
- [ ] Ensure TUTOR dashboard excludes budget information
- [ ] Add comprehensive unit tests for TUTOR dashboard logic

### Task 3: Implement LECTURER Dashboard Logic (AC2)  
- [ ] Implement getLecturerDashboard() method in DashboardServiceImpl
- [ ] Add course-filtering logic for LECTURER access control
- [ ] Implement calculateBudgetUsage() for course-level budget tracking
- [ ] Create getRecentActivitiesForCourses() method
- [ ] Create getPendingItemsForLecturer() method
- [ ] Create getWorkloadAnalysisForCourses() method
- [ ] Add validation for LECTURER course access permissions
- [ ] Add comprehensive unit tests for LECTURER dashboard logic

### Task 4: Implement ADMIN Dashboard Logic (AC3)
- [ ] Implement getAdminDashboard() method in DashboardServiceImpl  
- [ ] Add system-wide data aggregation queries
- [ ] Implement calculateSystemWideBudgetUsage() method
- [ ] Create getSystemWideRecentActivities() method
- [ ] Create getPendingItemsForAdmin() method
- [ ] Create getSystemWideWorkloadAnalysis() method
- [ ] Add comprehensive unit tests for ADMIN dashboard logic

### Task 5: Create DashboardController with Role-Based Access (AC1-AC5)
- [ ] Create DashboardController with GET /api/dashboard/summary endpoint
- [ ] Implement role-based authorization using @PreAuthorize
- [ ] Add proper parameter validation and date range handling
- [ ] Implement error handling following established patterns
- [ ] Add comprehensive JavaDoc documentation
- [ ] Create controller unit tests for all roles and error scenarios

### Task 6: Database Query Optimization
- [x] Add TimesheetSummaryData DTO for efficient aggregation
- [x] Implement aggregation queries in TimesheetRepository  
- [x] Add CourseRepository methods for lecturer-course mapping
- [ ] Create database indexes for dashboard query performance
- [ ] Test query performance with large datasets
- [ ] Optimize pagination for activity feeds

### Task 7: Security and Authorization Implementation
- [ ] Implement validateLecturerAccess() method for course filtering
- [ ] Add role-based data filtering in service layer
- [ ] Create comprehensive security tests for unauthorized access
- [ ] Test cross-user data access prevention
- [ ] Validate JWT token handling in controller
- [ ] Test role-based authorization boundaries

### Task 8: Input Validation and Error Handling
- [ ] Implement buildDateRange() method with semester parsing
- [ ] Add comprehensive input validation for all parameters
- [ ] Implement custom exception handling for dashboard-specific errors
- [ ] Add proper HTTP status code mapping
- [ ] Create error response DTOs matching OpenAPI specification
- [ ] Test all error scenarios and edge cases

### Task 9: Integration Testing and End-to-End Validation (AC1-AC5)
- [ ] Create DashboardControllerIntegrationTest test class
- [ ] Test AC1: TUTOR can retrieve personal timesheet summary
- [ ] Test AC2: LECTURER can retrieve course-level summaries with budget info
- [ ] Test AC3: ADMIN can retrieve system-wide summaries
- [ ] Test AC4: DashboardService correctly aggregates from existing services
- [ ] Test AC5: All responses conform to OpenAPI schemas
- [ ] Test role-based access control and security boundaries
- [ ] Test parameter filtering and date range functionality

### Task 10: Documentation and API Compliance
- [ ] Verify OpenAPI specification compliance for all response DTOs
- [ ] Update controller JavaDoc with role-specific examples
- [ ] Create user guide documentation for dashboard functionality
- [ ] Add code comments for complex aggregation logic
- [ ] Update error response documentation
- [ ] Verify JSON serialization matches OpenAPI examples

### Task 11: Performance Testing and Code Review Preparation
- [ ] Test API response times for dashboard summary queries
- [ ] Verify database query performance with realistic datasets
- [ ] Run load testing for concurrent dashboard requests
- [ ] Ensure code follows established coding standards and patterns
- [ ] Validate caching strategies for course-lecturer mappings
- [ ] Prepare comprehensive test coverage report for Story 3.1

## Testing

### Testing Standards
Following established project testing patterns [Source: docs/architecture/coding-standards.md]:
- **Unit Tests**: Service layer methods with 80%+ coverage using JUnit 5 and Mockito
- **Integration Tests**: Full API endpoint testing with TestContainers and PostgreSQL
- **Security Tests**: Role-based authorization and data access control
- **Performance Tests**: Query optimization and response time validation

### Test File Structure
Following project structure [Source: docs/architecture/project-structure.md]:
```
src/test/java/com/usyd/catams/
├── integration/
│   └── DashboardControllerIntegrationTest.java [New]
├── service/
│   └── DashboardServiceImplTest.java [New]
├── controller/
│   └── DashboardControllerTest.java [New]
└── security/
    └── DashboardAccessControlTest.java [New]
```

### Key Test Scenarios
- **Role-Based Access**: Each role receives appropriate data scope
- **Data Aggregation**: Accurate metrics calculation from existing services
- **Security Boundaries**: Proper enforcement of role-based data access
- **OpenAPI Compliance**: Response schemas match specification exactly
- **Performance**: Dashboard queries complete within acceptable time limits

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-03 | 1.0 | Initial story creation with comprehensive technical analysis | Scrum Master (SuperClaude) |

## Dev Agent Record
**Agent Model Used:** Claude 4 Sonnet  
**Implementation Started:** [To be updated by development agent]

### Implementation Status
- [ ] Task 1: Create DashboardService interface and core DTOs
- [ ] Task 2: Implement TUTOR dashboard logic
- [ ] Task 3: Implement LECTURER dashboard logic  
- [ ] Task 4: Implement ADMIN dashboard logic
- [ ] Task 5: Create DashboardController with role-based access
- [ ] Task 6: Database query optimization
- [ ] Task 7: Security and authorization implementation
- [ ] Task 8: Input validation and error handling
- [ ] Task 9: Integration testing and end-to-end validation
- [ ] Task 10: Documentation and API compliance
- [ ] Task 11: Performance testing and code review preparation

### File Modifications Required
**New Files**:
- `src/main/java/com/usyd/catams/service/DashboardService.java`
- `src/main/java/com/usyd/catams/service/impl/DashboardServiceImpl.java`
- `src/main/java/com/usyd/catams/controller/DashboardController.java`
- `src/main/java/com/usyd/catams/dto/response/DashboardSummaryResponse.java`
- `src/main/java/com/usyd/catams/dto/response/BudgetUsage.java`
- `src/main/java/com/usyd/catams/dto/response/RecentActivity.java`
- `src/main/java/com/usyd/catams/dto/response/PendingItem.java`
- `src/main/java/com/usyd/catams/dto/response/WorkloadAnalysis.java`
- `src/main/java/com/usyd/catams/dto/TimesheetSummaryData.java`
- `src/test/java/com/usyd/catams/integration/DashboardControllerIntegrationTest.java`
- `src/test/java/com/usyd/catams/service/DashboardServiceImplTest.java`
- `src/test/java/com/usyd/catams/controller/DashboardControllerTest.java`
- `src/test/java/com/usyd/catams/security/DashboardAccessControlTest.java`

**Modified Files**:
- `src/main/java/com/usyd/catams/repository/TimesheetRepository.java` - Add aggregation queries
- `src/main/java/com/usyd/catams/repository/CourseRepository.java` - Add lecturer-course mapping methods

## QA Results
*This section will be populated by the QA Agent after story completion*

---
**Created:** 2025-08-03  
**Last Updated:** 2025-08-03  
**Status:** Ready for Development